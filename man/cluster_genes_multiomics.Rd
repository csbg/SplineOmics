% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster_genes_multiomics.R
\name{cluster_genes_multiomics}
\alias{cluster_genes_multiomics}
\title{Gene-Centric Multi-Omics Clustering Across Blocks and Layers}
\usage{
cluster_genes_multiomics(
  blocks,
  block_meta,
  modality_meta,
  gene_mode = "intersection",
  verbose = TRUE
)
}
\arguments{
\item{blocks}{A named nested list specifying all data used for clustering.
The outer list corresponds to analytical \emph{blocks} (e.g.,
\code{time_Ctrl}, \code{interaction_Ctrl_vs_Treat}).
Each element of the outer list is itself a named list whose elements are
\emph{modalities} (e.g., \code{rna}, \code{protein}, \code{phospho}), each
being a numeric matrix of dimension \code{features x spline_points}.

For one-to-one (gene-level) modalities, rows represent genes directly.
In this case, row names must be the gene identifiers themselves and must
follow the pattern \code{<gene_id>}. The angle brackets are shown for
illustration only and must not be included in the actual row names.
Gene identifiers must be consistent across all one-to-one layers; otherwise,
genes cannot be matched across omics layers during distance computation and
clustering.

For many-to-one modalities (e.g., phospho sites, probes), rows represent
features that map to genes and are summarized into gene-level pattern
signatures
based on the metadata tables. For these modalities, row names must follow the
pattern \code{<gene_id>_<feature_id>}, where the gene identifier precedes
the first underscore. Again, the angle brackets are for illustration only
and must not be included in the actual row names.

This row-naming convention is critical, as it defines how features are
associated with genes and how genes are aligned across modalities prior to
signature construction and downstream clustering.}

\item{block_meta}{A data frame containing \emph{block-level metadata}. One row per block.
Must include:
\describe{
\item{\code{block}}{Block identifier (must match names in \code{blocks}).}
\item{\code{block_k}}{Number of gene clusters for this block.}
\item{\code{result_category}}{Numeric result category label (e.g., 1 for
time effect, 3 for interaction).}
\item{\code{cond1}}{Primary condition associated with this block (e.g.,
condition for time-effect blocks, or first condition in a contrast).}
\item{\code{cond2}}{Secondary condition for contrast-based blocks. Set to
\code{NA} for single-condition blocks.}
}}

\item{modality_meta}{A data frame containing \emph{modality-level metadata}. One row per (block ×
modality). Must include:
\describe{
\item{\code{block}}{Block identifier linking to \code{block_meta}.}
\item{\code{layer}}{Modality name within the block.}
\item{\code{layer_k}}{Number of pattern clusters to use for building
pattern signatures for many-to-one modalities. \code{NA} for modalities
that are already gene-level.}
\item{\code{layer_w}}{
Relative weight of this modality when combining modality-specific
gene–gene distances within the block. Values are treated as
\emph{relative} weights and are normalized internally, so they do not
need to sum to 1 (e.g. 1, 1, 2 means the third modality has twice
the weight of the others).
}
}}

\item{gene_mode}{Character string specifying how genes should be harmonized across modalities
within each block prior to clustering.
\describe{
\item{\code{"intersection"}}{Retain only genes present in \emph{all}
modalities of the block. Produces the most interpretable multi-omics
clusters.}

\item{\code{"union"}}{Retain genes present in \emph{any} modality of the
block. Gene–gene distances are computed using only shared modalities per
gene pair, with weights renormalized accordingly. Increases coverage but
results in heterogeneous information across genes.}
}}

\item{verbose}{Boolean flag indicating if info messages are be shown.}
}
\value{
A named list with two tibbles:

\describe{
\item{\code{cluster_table}}{A tibble with one row per gene containing
block-specific cluster assignments suitable for downstream enrichment
analyses. Columns include the gene identifier and one clustering column
per analytical block (e.g., \code{cluster_<cond>} or
\code{cluster_cat3_<cond1>_vs_<cond2>}). Genes not included in a given
block are assigned \code{NA}.}

\item{\code{centroid_info}}{A tibble with one row per block, modality
(layer), and cluster, summarizing modality-specific cluster centroid
trajectories and within-cluster coherence. Columns include the block
and layer identifiers, cluster label, gene coverage statistics, mean
and standard deviation of per-gene \eqn{R^2} values, optional per-gene
\eqn{R^2} vectors, and the centroid trajectory stored as a list-column.}
}
}
\description{
Performs gene-centric clustering of multi-omics time-series data across
multiple blocks (e.g., time effect, interaction effect) and data modalities
(e.g., transcript, protein, feature-level modalities with many-to-one gene
mapping). The function integrates multiple modalities within each block by
computing modality-specific gene–gene distances, combining them via
user-defined weights, and clustering genes based on the resulting unified
distance matrix.

The function is flexible with respect to how spline trajectories,
interaction representations, or feature-level signatures are constructed:
these are precomputed outside the function, and supplied as matrices inside
the \code{blocks} structure. Internally, the function simply performs
harmonization of genes, distance computation, weighted integration, and
clustering.
}
\examples{
set.seed(1)

genes <- paste0("gene", 1:6)

rna_time_ctrl <- matrix(
    rnorm(6 * 5),
    nrow = 6,
    ncol = 5,
    dimnames = list(genes, NULL)
)
rna_time_treat <- matrix(
    rnorm(6 * 5),
    nrow = 6,
    ncol = 5,
    dimnames = list(genes, NULL)
)

blocks <- list(
    time_Ctrl = list(rna = rna_time_ctrl),
    time_Treat = list(rna = rna_time_treat)
)

block_meta <- data.frame(
    block           = c("time_Ctrl", "time_Treat"),
    block_k         = c(2L, 2L),
    result_category = c(1, 1),
    cond1           = c("Ctrl", "Treat"),
    cond2           = c(NA_character_, NA_character_),
    stringsAsFactors = FALSE
)

modality_meta <- data.frame(
    block   = c("time_Ctrl", "time_Treat"),
    layer   = c("rna", "rna"),
    layer_k = c(NA_real_, NA_real_),
    layer_w = c(1, 1),
    stringsAsFactors = FALSE
)

cluster_table <- cluster_genes_multiomics(
    blocks     = blocks,
    block_meta = block_meta,
    modality_meta = modality_meta,
    gene_mode  = "intersection"
)

cluster_table

}
