% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster_genes_multiomics.R
\name{cluster_genes_multiomics}
\alias{cluster_genes_multiomics}
\title{Gene-Centric Multi-Omics Clustering Across Blocks and Data Modalities}
\usage{
cluster_genes_multiomics(
  blocks,
  block_clusters,
  modality_meta,
  gene_mode = "intersection",
  verbose = TRUE
)
}
\arguments{
\item{blocks}{A named nested list specifying all data used for clustering.
The outer list corresponds to analytical \emph{blocks} (e.g.,
\code{time_Ctrl}, \code{interaction_Ctrl_vs_Treat}).
Each element of the outer list is itself a named list whose elements are
\emph{modalities} (e.g., \code{rna}, \code{protein}, \code{phospho}), each
being a numeric matrix of dimension \code{features x spline_points}.

For one-to-one (gene-level) modalities, rows represent genes directly.
In this case, row names must be the gene identifiers themselves and must
follow the pattern \code{<gene_id>}. The angle brackets are shown for
illustration only and must not be included in the actual row names.
Gene identifiers must be consistent across all one-to-one modalities;
otherwise, genes cannot be matched across omics modalities during distance
computation and clustering.

For many-to-one modalities (e.g., phospho sites, probes), rows represent
features that map to genes and are summarized into gene-level pattern
signatures
based on the metadata tables. For these modalities, row names must follow the
pattern \code{<gene_id>_<feature_id>}, where the gene identifier precedes
the first underscore. Again, the angle brackets are for illustration only
and must not be included in the actual row names.

This row-naming convention is critical, as it defines how features are
associated with genes and how genes are aligned across modalities prior to
signature construction and downstream clustering.}

\item{block_clusters}{A named list specifying the amount of clusters per block. The list names
must match the names of \code{blocks}. Each element value specifies the
number of gene clusters (\code{k}) to compute for the corresponding
block.}

\item{modality_meta}{A data frame containing \emph{modality-level metadata}. One row per (block ×
modality). Must include:
\describe{
\item{\code{block}}{Block identifier linking to \code{block_meta}.}
\item{\code{modality}}{Modality name within the block.}
\item{\code{many_to_one_k}}{Number of pattern clusters to use for building
pattern signatures for many-to-one modalities. \code{NA} for modalities
that are already gene-level.}
\item{\code{modality_w}}{
Relative weight of this modality when combining modality-specific
gene–gene distances within the block. Values are treated as
\emph{relative} weights and are normalized internally, so they do not
need to sum to 1 (e.g. 1, 1, 2 means the third modality has twice
the weight of the others).
}
}}

\item{gene_mode}{Character string specifying how genes should be harmonized across modalities
within each block prior to clustering.
\describe{
\item{\code{"intersection"}}{Retain only genes present in \emph{all}
modalities of the block. Produces the most interpretable multi-omics
clusters.}

\item{\code{"union"}}{Retain genes present in \emph{any} modality of the
block. Gene–gene distances are computed using only shared modalities per
gene pair, with weights renormalized accordingly. Increases coverage but
results in heterogeneous information across genes.}
}}

\item{verbose}{Boolean flag indicating if info messages are be shown.}
}
\value{
A named list with three tibbles:

\describe{
\item{\code{cluster_table}}{A tibble with one row per gene containing
block-specific cluster assignments suitable for downstream enrichment
analyses. Columns include the gene identifier and one clustering column
per analytical block (e.g., \code{cluster_<cond>} or
\code{cluster_cat3_<cond1>_vs_<cond2>}). Genes not included in a given
block are assigned \code{NA}.}

\item{\code{centroid_info}}{A tibble with one row per block, modality,
and cluster, summarizing modality-specific cluster centroids and
within-cluster coherence. Columns include the block and modality
identifiers, cluster label, gene coverage statistics, the QC method
used (\code{qc_method}; \code{"Pearson R2"} for one-to-one modalities
and \code{"BC(HD)"} for many-to-one modalities), mean and standard
deviation of per-gene QC values (\code{mean_qc}, \code{sd_qc}),
optional per-gene QC vectors (\code{qc_member}) as a list-column, and
the centroid representation stored as a list-column (\code{centroid}).}

\item{\code{many_to_one_clustering_qc}}{A tibble (or \code{NULL} if no
many-to-one modalities are present) providing clustering quality
diagnostics for many-to-one feature clustering steps. One row per
block, modality, and feature-cluster, including the many-to-one
\code{k} value used, the number of features used, the QC method
(\code{"Pearson R2"}), mean and standard deviation of per-feature QC
values (\code{mean_qc}, \code{sd_qc}), optional per-feature QC vectors
(\code{qc_member}) as a list-column, and the centroid representation
stored as a list-column (\code{centroid}).}
}
}
\description{
Performs gene-centric clustering of multi-omics time-series data across
multiple blocks (e.g., time effect, interaction effect) and data modalities
(e.g., transcript, protein, feature-level modalities with many-to-one gene
mapping). The function integrates multiple modalities within each block by
computing modality-specific gene–gene distances, combining them via
user-defined weights, and clustering genes based on the resulting unified
distance matrix.

The function is flexible with respect to how spline trajectories,
interaction representations, or feature-level signatures are constructed:
these are precomputed outside the function, and supplied as matrices inside
the \code{blocks} structure. Internally, the function simply performs
harmonization of genes, distance computation, weighted integration, and
clustering.
}
\examples{
set.seed(1)

genes <- paste0("gene", 1:6)

rna_time_ctrl <- matrix(
    rnorm(6 * 5),
    nrow = 6,
    ncol = 5,
    dimnames = list(genes, NULL)
)
rna_time_treat <- matrix(
    rnorm(6 * 5),
    nrow = 6,
    ncol = 5,
    dimnames = list(genes, NULL)
)

blocks <- list(
    time_Ctrl = list(rna = rna_time_ctrl),
    time_Treat = list(rna = rna_time_treat)
)

block_clusters <- list(
    time_Ctrl = 2L,
    time_Treat = 2L
)

modality_meta <- data.frame(
    block   = c("time_Ctrl", "time_Treat"),
    modality   = c("rna", "rna"),
    many_to_one_k = c(NA_real_, NA_real_),
    modality_w = c(1, 1),
    stringsAsFactors = FALSE
)

cluster_table <- cluster_genes_multiomics(
    blocks     = blocks,
    block_clusters = block_clusters,
    modality_meta = modality_meta,
    gene_mode  = "intersection"
)

cluster_table

}
