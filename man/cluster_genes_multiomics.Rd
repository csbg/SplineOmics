% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster_genes_multiomics.R
\name{cluster_genes_multiomics}
\alias{cluster_genes_multiomics}
\title{Gene-Centric Multi-Omics Clustering Across Blocks and Layers}
\usage{
cluster_genes_multiomics(
  blocks,
  block_meta,
  layer_meta,
  gene_mode = "intersection",
  verbose = TRUE
)
}
\arguments{
\item{blocks}{A named nested list specifying all data used for clustering.
The outer list corresponds to analytical \emph{blocks} (e.g.,
\code{time_Ctrl}, \code{interaction_Ctrl_vs_Treat}).
Each element of the outer list is itself a named list whose elements are
\emph{layers} (e.g., \code{rna}, \code{protein}, \code{phospho}), each being
a numeric matrix of dimension \code{features x spline_points}.

For one-to-one (gene-level) layers, rows represent genes directly.
In this case, row names must be the gene identifiers themselves and must
follow the pattern \code{<gene_id>}. The angle brackets are shown for
illustration only and must not be included in the actual row names.
Gene identifiers must be consistent across all one-to-one layers; otherwise,
genes cannot be matched across omics layers during distance computation and
clustering.

For many-to-one layers (e.g., phospho sites, probes), rows represent features
that map to genes and are summarized into gene-level pattern signatures
based on the metadata tables. For these layers, row names must follow the
pattern \code{<gene_id>_<feature_id>}, where the gene identifier precedes
the first underscore. Again, the angle brackets are for illustration only
and must not be included in the actual row names.

This row-naming convention is critical, as it defines how features are
associated with genes and how genes are aligned across layers prior to
signature construction and downstream clustering.}

\item{block_meta}{A data frame containing \emph{block-level metadata}. One row per block.
Must include:
\describe{
\item{\code{block}}{Block identifier (must match names in \code{blocks}).}
\item{\code{block_k}}{Number of gene clusters for this block.}
\item{\code{result_category}}{Numeric result category label (e.g., 1 for
time effect, 3 for interaction).}
\item{\code{cond1}}{Primary condition associated with this block (e.g.,
condition for time-effect blocks, or first condition in a contrast).}
\item{\code{cond2}}{Secondary condition for contrast-based blocks. Set to
\code{NA} for single-condition blocks.}
}}

\item{layer_meta}{A data frame containing \emph{layer-level metadata}. One row per (block ×
layer). Must include:
\describe{
\item{\code{block}}{Block identifier linking to \code{block_meta}.}
\item{\code{layer}}{Layer name within the block.}
\item{\code{layer_k}}{Number of pattern clusters to use for building
pattern signatures for many-to-one layers. \code{NA} for layers that are
already gene-level.}
\item{\code{layer_w}}{
Relative weight of this layer when combining layer-specific
gene–gene distances within the block. Values are treated as
\emph{relative} weights and are normalized internally, so they do not
need to sum to 1 (e.g. 1, 1, 2 means the third layer has twice
the weight of the others).
}
}}

\item{gene_mode}{Character string specifying how genes should be harmonized across layers
within each block prior to clustering.
\describe{
\item{\code{"intersection"}}{Retain only genes present in \emph{all}
layers of the block. Produces the most interpretable multi-omics clusters.}

\item{\code{"union"}}{Retain genes present in \emph{any} layer of the
block. Gene–gene distances are computed using only shared layers per gene
pair, with weights renormalized accordingly. Increases coverage but results
in heterogeneous information across genes.}
}}

\item{verbose}{Boolean flag indicating if info messages are be shown.}
}
\value{
A tibble \code{cluster_table} with one row per gene and columns containing
all block-specific clustering results in a format suitable for downstream
enrichment analyses.
The table includes:

\describe{
\item{\code{gene}}{Gene identifier used for clustering.}

\item{\code{feature_nr}}{Optional numeric identifier if available in the
input.}

\item{\code{feature_name}}{Optional human-readable feature/gene name.}

\item{\code{cluster_<cond>}}{Integer cluster assignment for each
time-effect block (result category 1). One column per condition, derived
from \code{block_meta$cond1}.}

\item{\code{cluster_cat3_<cond1>_vs_<cond2>}}{Character cluster label for
each interaction block (result category 3). Column names follow the pattern
\code{"cluster_cat3_<cond1>_vs_<cond2>"}. Values are cluster assignments
for genes clustered in the corresponding block, and \code{NA} for genes
not included in that block.}
}

All clustering columns contain \code{NA} for genes that were not included in
the given block (e.g., due to \code{gene_mode = "intersection"} or missing
layers in a block).
}
\description{
Performs gene-centric clustering of multi-omics time-series data across
multiple \emph{blocks} (e.g., time effect, interaction effect) and \emph{layers}
(e.g., transcript, protein, feature-level layers with many-to-one gene
mapping). The function integrates multiple omics layers within each block by
computing layer-specific gene–gene distances, combining them via user-defined
weights, and clustering genes based on the resulting unified distance matrix.

The function is flexible with respect to how spline trajectories,
interaction representations, or feature-level signatures are constructed:
these are precomputed outside the function, and supplied as matrices inside
the \code{blocks} structure. Internally, the function simply performs
harmonization of genes, distance computation, weighted integration, and
clustering.
}
\examples{
set.seed(1)

genes <- paste0("gene", 1:6)

rna_time_ctrl <- matrix(
    rnorm(6 * 5),
    nrow = 6,
    ncol = 5,
    dimnames = list(genes, NULL)
)
rna_time_treat <- matrix(
    rnorm(6 * 5),
    nrow = 6,
    ncol = 5,
    dimnames = list(genes, NULL)
)

blocks <- list(
    time_Ctrl = list(rna = rna_time_ctrl),
    time_Treat = list(rna = rna_time_treat)
)

block_meta <- data.frame(
    block           = c("time_Ctrl", "time_Treat"),
    block_k         = c(2L, 2L),
    result_category = c(1, 1),
    cond1           = c("Ctrl", "Treat"),
    cond2           = c(NA_character_, NA_character_),
    stringsAsFactors = FALSE
)

layer_meta <- data.frame(
    block   = c("time_Ctrl", "time_Treat"),
    layer   = c("rna", "rna"),
    layer_k = c(NA_real_, NA_real_),
    layer_w = c(1, 1),
    stringsAsFactors = FALSE
)

cluster_table <- cluster_genes_multiomics(
    blocks     = blocks,
    block_meta = block_meta,
    layer_meta = layer_meta,
    gene_mode  = "intersection"
)

cluster_table

}
