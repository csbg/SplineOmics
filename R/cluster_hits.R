#' cluster_hits.R contains the exported package function cluster_hits and all
#' the functions that make up the functionality of cluster_hits. cluster_hits
#' clusters the hits of a time series omics datasets (the features that were
#' significantly changed over the time course) with hierarchical clustering of
#' the spline shape.


# Exported function: cluster_hits() --------------------------------------------


#' Cluster Hits from Top Tables
#'
#' Performs clustering on hits from top tables generated by differential
#' expression analysis.
#' This function filters hits based on adjusted p-value thresholds, extracts
#' spline coefficients for
#' significant features, normalizes these coefficients, and applies hierarchical
#' clustering. The results,
#' including clustering assignments and normalized spline curves, are saved in a
#' specified directory and
#' compiled into an HTML report.
#'
#' @param splineomics An S3 object of class `SplineOmics` that contains all the 
#' necessary data and parameters for the analysis, including:
#' \itemize{
#'   \item \code{data}: The original expression dataset used for differential 
#'   expression analysis.
#'   \item \code{meta}: A dataframe containing metadata corresponding to the 
#'   \code{data}, must include a 'Time' column and any columns specified by 
#'   \code{conditions}.
#'   \item \code{design}: A character of length 1 representing the limma 
#'   design formula.
#'   \item \code{condition}: Character of length 1 specifying the column name 
#'   in \code{meta} used to define groups for analysis.
#'   \item \code{spline_params}: A list of spline parameters for the analysis.
#'   \item \code{meta_batch_column}: A character string specifying the column 
#'   name in the metadata used for batch effect removal.
#'   \item \code{meta_batch2_column}: A character string specifying the second 
#'   column name in the metadata used for batch effect removal.
#'   \item \code{limma_splines_result}: A list of data frames, each representing
#'    a top table from differential expression analysis, containing at least 
#'    'adj.P.Val' and expression data columns.
#' }
#' @param clusters Character or integer vector specifying the number of clusters
#' @param adj_pthresholds Numeric vector of p-value thresholds for filtering 
#' hits in each top table.
#' @param adj_pthresh_avrg_diff_conditions p-value threshold for the results
#' from the average difference of the condition limma result. Per default 0 (
#' turned off).
#' @param adj_pthresh_interaction_condition_time p-value threshold for the 
#' results from the interaction of condition and time limma result. Per default 
#' 0 (turned off).
#' @param genes A character vector containing the gene names of the features to
#'  be analyzed.
#' @param plot_info List containing the elements y_axis_label (string), 
#'                  time_unit (string), treatment_labels (character vector),
#'                  treatment_timepoints (integer vector). All can also be NA. 
#'                  This list is used to add this info to the spline plots. 
#'                  time_unit is used to label the x-axis, and treatment_labels
#'                  and -timepoints are used to create vertical dashed lines,
#'                  indicating the positions of the treatments (such as 
#'                  feeding, temperature shift, etc.).
#' @param plot_options List with specific fields (cluster_heatmap_columns = 
#' Bool) that allow for customization of plotting behavior.
#' @param report_dir Character string specifying the directory path where the
#' HTML report and any other output files should be saved.
#' @param report Boolean TRUE or FALSE value specifing if a report should be
#' generated.
#'
#' @return A list where each element corresponds to a group factor and contains
#' the clustering results,
#'         including `clustered_hits` data frame, hierarchical clustering object
#'         `hc`, `curve_values`
#'         data frame with normalized spline curves, and `top_table` with
#'         cluster assignments.
#'
#' @seealso \code{\link[limma]{topTable}}, \code{\link[stats]{hclust}}
#'
#' @export
#'
cluster_hits <- function(
    splineomics,
    clusters,
    adj_pthresholds = c(0.05),
    adj_pthresh_avrg_diff_conditions = 0,
    adj_pthresh_interaction_condition_time = 0,
    genes = NULL,       # Underlying genes of the features
    plot_info = list(
      y_axis_label = "Value",
      time_unit = "min",
      treatment_labels = NA,
      treatment_timepoints = NA
      ),
    plot_options = list(
      cluster_heatmap_columns = FALSE,
      meta_replicate_column = NULL
    ),
    report_dir = here::here(),
    report = TRUE
    ) {

  report_dir <- normalizePath(
    report_dir,
    mustWork = FALSE
    )
  
  check_splineomics_elements(
    splineomics = splineomics,
    func_type = "cluster_hits"
  )

  args <- lapply(as.list(match.call()[-1]), eval, parent.frame())
  check_null_elements(args)
  input_control <- InputControl$new(args)
  input_control$auto_validate()
  
  top_tables <- splineomics[['limma_splines_result']][['time_effect']]
  data <- splineomics[["data"]]
  meta <- splineomics[["meta"]]
  annotation <- splineomics[["annotation"]]
  report_info <- splineomics[["report_info"]]
  design <- splineomics[["design"]]
  mode <- splineomics[["mode"]]
  condition <- splineomics[["condition"]]
  spline_params <- splineomics[["spline_params"]]
  meta_batch_column <- splineomics[["meta_batch_column"]]
  meta_batch2_column <- splineomics[["meta_batch2_column"]]
  feature_name_columns <- splineomics[["feature_name_columns"]]

  # To set the default p-value threshold for ALL levels.
  if (is.numeric(adj_pthresholds) &&
      length(adj_pthresholds) == 1 && adj_pthresholds[1] == 0.05) {
    levels <- unique(meta[[condition]])
    adj_pthresholds <- rep(adj_pthresholds[1], length(levels))
  }
  
  within_level_top_tables <- filter_top_tables(
    top_tables = top_tables,
    adj_pthresholds = adj_pthresholds,
    meta = meta,
    condition = condition
    )

  huge_table_user_prompter(within_level_top_tables)
  
  all_levels_clustering <- perform_clustering(
    top_tables = within_level_top_tables,
    clusters = clusters,
    meta = meta,
    condition = condition,
    spline_params = spline_params,
    mode = mode
    )

  report_info$limma_design <- c(design)
  report_info$meta_condition <- c(condition)
  report_info$meta_batch <- paste(
    meta_batch_column,
    meta_batch2_column,
    sep = ", "
    )
  
  
  if (adj_pthresh_avrg_diff_conditions > 0 || 
      adj_pthresh_interaction_condition_time > 0) {
    
    spline_comp_plots <- generate_spline_comparisons(
      splineomics = splineomics,
      all_levels_clustering = all_levels_clustering,
      data = data,
      meta = meta,
      condition = condition,
      plot_info = plot_info,
      adj_pthresh_avrg_diff_conditions = adj_pthresh_avrg_diff_conditions,
      adj_pthresh_interaction = adj_pthresh_interaction_condition_time
    )
  } else {
    spline_comp_plots <- NULL
  }
  

  if (!is.null(genes)) {
    genes <- clean_gene_symbols(genes)
  }
  
  if (report) {
    plots <- make_clustering_report(
      all_levels_clustering = all_levels_clustering,
      condition = condition,
      data = data,
      meta = meta,
      annotation = annotation,
      genes = genes,
      spline_params = spline_params,
      adj_pthresholds = adj_pthresholds,
      report_dir = report_dir,
      mode = mode,
      report_info = report_info,
      design = design,
      meta_batch_column = meta_batch_column,
      meta_batch2_column = meta_batch2_column,
      plot_info = plot_info,
      plot_options = plot_options,
      feature_name_columns = feature_name_columns,
      spline_comp_plots = spline_comp_plots
      )
  } else {
    plots <- "no plots, because report arg of cluster_hits() was set to FALSE"
  }

  # Leave a message for the user instead of just NA.
  all_levels_clustering <- lapply(all_levels_clustering, function(x) {
    if (is.logical(x)) {
      return("No result for this level, because the top_table had < 2 hits")
    } else {
      return(x)
    }
  })
  
  clustered_hits_levels <- list()
  
  for (i in seq_along(all_levels_clustering)) {
    clustering_level <- all_levels_clustering[[i]]
    element_name <- names(all_levels_clustering)[i]
    
    if (any(is.character(clustering_level))) {
      clustered_hits_levels[[element_name]] <- 
        clustering_level
    }
    else {                                       # normal list result
      clustered_hits_levels[[element_name]] <- 
        clustering_level$clustered_hits
    }
  }
  
  if (!is.null(genes)) {
    # Add gene column for the run_gsea() function.
    clustered_hits_levels <- lapply(clustered_hits_levels, function(df) {
      if (is.character(df)) {
        return(df)  
      }
      df$gene <- genes[df$feature]
      return(df)
    })
  }
  
  print_info_message(
    message_prefix = "Clustering the hits",
    report_dir = report_dir
  )
  
  list(
    all_levels_clustering = all_levels_clustering,
    plots = plots,
    clustered_hits_levels = clustered_hits_levels
    )
}



# Level 1 internal functions ---------------------------------------------------


filter_top_tables <- function(
    top_tables,
    adj_pthresholds,
    meta,
    condition
    ) {

  result <- check_between_level_pattern(top_tables)

  if (result$between_levels) {                     # between_level analysis
    if (result$index_with_pattern == 1) {
      within_level_top_tables_index <- 2
      between_level_top_tables_index <- 1
    } else {                        # between level top_tables are at index 2
      within_level_top_tables_index <- 1
      between_level_top_tables_index <- 2
    }

    within_level_top_tables <- top_tables[[within_level_top_tables_index]]
    between_level_top_tables <- top_tables[[between_level_top_tables_index]]

  } else {                                  # no between level analysis
    within_level_top_tables <- top_tables
  }

  for (i in seq_along(within_level_top_tables)) {

    within_level_top_table <- within_level_top_tables[[i]]
    level <- unique(meta[[condition]])[i]

    if (result$between_levels) {
      hit_indices <- get_level_hit_indices(between_level_top_tables,
                                           level,
                                           adj_pthresholds)
    } else {    # within level
      hit_indices <- within_level_top_table[["feature_nr"]][
        within_level_top_table[["adj.P.Val"]] < adj_pthresholds[i]
      ]
    }

    top_table_filtered <-
      within_level_top_table[within_level_top_table[["feature_nr"]]
                             %in% hit_indices, ]

    if (nrow(top_table_filtered) < 2) {
      message(paste("Level", level, "has < 2 hits. Skipping clustering for",
                    "this level"))
      within_level_top_tables[[i]] <- NA
    } else {
      within_level_top_tables[[i]] <- top_table_filtered
    }

  }

  if (all(is.na(within_level_top_tables))) {
    stop("All levels have < 2 hits. Cannot run clustering.", call. = FALSE)
  }

  within_level_top_tables
}


#' Check if any table in a list has more than 300 rows and prompt user for 
#' input.
#'
#' This function iterates over a list of tables and checks if any table has
#'  more than 300 rows.
#' If such a table is found, it prompts the user to proceed or stop.
#'
#' @param tables A list of data frames.
#' @return NULL. This function is used for its side effects (prompting the 
#' user and potentially stopping the script).
#' 
huge_table_user_prompter <- function(tables) {
  
  for (i in seq_along(tables)) {

    if (any(is.logical(tables[[i]]))) {
      next
    }
    
    if (nrow(tables[[i]]) > 500) {
      # Prompt the user for input
      while (TRUE) {
        user_input <- readline(prompt = paste(
          "The table",
          names(tables)[i], 
          "has more than 500 rows. Do you want to proceed? (y/n): "
          ))
        user_input <- tolower(user_input)
        
        # Check user input
        if (user_input == 'y') {
          # Proceed
          print("Proceeding...")
          break  
        } else if (user_input == 'n') {
          stop("Script stopped. User chose not to proceed.", call. = FALSE)
        } else {
          # Invalid input, ask the user again
          cat(paste(
            "Invalid input. Please type 'y' to proceed or 'n' to stop", 
            "the script.\n"
            ))
        }
      }
    }
  }
}


#' Perform Clustering
#'
#' @description
#' Performs clustering on top tables using specified p-values and clusters
#' for each level within a condition.
#'
#' @param top_tables A list of top tables from limma analysis.
#' @param clusters A list specifying clusters.
#' @param meta A dataframe containing metadata.
#' @param condition A character string specifying the condition.
#' @param spline_params A list of spline parameters for the analysis.
#' @param mode A character string specifying the mode
#' ('isolated' or 'integrated').
#'
#' @return A list of clustering results for each level within the condition.
#'
#' @seealso
#' \code{\link{process_level_cluster}}
#'
perform_clustering <- function(
    top_tables,
    clusters,
    meta,
    condition,
    spline_params,
    mode
    ) {

  levels <- unique(meta[[condition]])

  all_levels_clustering <- mapply(
    process_level_cluster,
    top_tables,
    clusters,
    levels,
    MoreArgs = list(
      meta = meta,
      condition = condition,
      spline_params = spline_params,
      mode = mode
      ),
    SIMPLIFY = FALSE
    )  # Return a list
  
  return(all_levels_clustering)
}


#' Make Clustering Report
#'
#' @description
#' Generates a detailed clustering report including heatmaps, dendrograms,
#' curve plots, and consensus shapes for each level within a condition.
#'
#' @param all_levels_clustering A list containing clustering results for each
#' level within a condition.
#' @param condition A character string specifying the condition.
#' @param data A matrix of data values.
#' @param meta A dataframe containing metadata.
#' @param annotation Dataframe containig the annotation info of the features,
#'                   such as gene and uniprotID, for example.
#' @param genes Character vector containing the genes of the features.
#' @param spline_params A list of spline parameters for the analysis.
#' @param adj_pthresholds Numeric vector, containing a float < 1 > 0 as each 
#'                        value. There is one float for every level, and this is
#'                        the adj. p-value threshold. 
#' @param report_dir A character string specifying the report directory.
#' @param mode A character string specifying the mode
#' ('isolated' or 'integrated').
#' @param report_info An object containing report information.
#' @param design A string representing the limma design formula
#' @param meta_batch_column A character string specifying the meta batch column.
#' @param meta_batch2_column A character string specifying the second meta 
#'                           batch column.
#' @param plot_info List containing the elements y_axis_label (string), 
#'                  time_unit (string), treatment_labels (character vector),
#'                  treatment_timepoints (integer vector). All can also be NA. 
#'                  This list is used to add this info to the spline plots. 
#'                  time_unit is used to label the x-axis, and treatment_labels
#'                  and -timepoints are used to create vertical dashed lines,
#'                  indicating the positions of the treatments (such as 
#'                  feeding, temperature shift, etc.).
#' @param plot_options List with specific fields (cluster_heatmap_columns = 
#' Bool) that allow for customization of plotting behavior.
#' @param feature_name_columns Character vector containing the column names of 
#'                             the annotation info that describe the features.
#'                             This argument is used to specify in the HTML 
#'                             report how exactly the feature names displayed
#'                             above each individual spline plot have been
#'                             created. Use the same vector that was used to 
#'                             create the row headers for the data matrix!
#' @param spline_comp_plots List containing the list of lists with all
#' the plots for all the pairwise comparisons of the condition in terms of
#' average spline diff and interaction condition time, and another list of lists
#' where the respective names of each plot are stored.
#'
#' @return No return value, called for side effects.
#'
#' @seealso
#' \code{\link{removeBatchEffect}}, \code{\link{plot_heatmap}},
#' \code{\link{plot_cluster_mean_splines}}, \code{\link{plot_splines}},
#' \code{\link{generate_report_html}}
#'
#' @importFrom limma removeBatchEffect
#' @importFrom dplyr filter
#' @importFrom stats na.omit
#' @importFrom rlang .data
#'
make_clustering_report <- function(
    all_levels_clustering,
    condition,
    data,
    meta,
    annotation,
    genes,
    spline_params,
    adj_pthresholds,
    report_dir,
    mode,
    report_info,
    design,
    meta_batch_column,
    meta_batch2_column,
    plot_info,
    plot_options,
    feature_name_columns,
    spline_comp_plots
    ) {

  # Optionally remove the batch-effect with the batch column and design matrix
  # For mode == "integrated", the batch-effect is removed from the whole data
  # For mode == "isolated", the batch-effect is removed for every level
  datas <- remove_batch_effect_cluster_hits(
    data = data,
    meta = meta,
    condition = condition,
    meta_batch_column = meta_batch_column,
    meta_batch2_column = meta_batch2_column,
    design = design,
    mode = mode,
    spline_params = spline_params
    )


  # To extract the stored value for the potential auto cluster decision.
  clusters <- c()
  for (i in seq_along(all_levels_clustering)) {

    if (is.null(all_levels_clustering[[i]]) ||
        all(is.na(all_levels_clustering[[i]]))) {
      next
    }

    clusters <- c(clusters, as.integer(all_levels_clustering[[i]]$clusters))
    all_levels_clustering[[i]]$clusters <- NULL
  }

  if (!dir.exists(report_dir)) {
    dir.create(report_dir)
  }

  time_unit_label <- paste0("[", plot_info$time_unit, "]")

  heatmaps <- plot_heatmap(
    datas = datas,
    meta = meta,
    mode = mode,
    condition = condition,
    all_levels_clustering = all_levels_clustering,
    time_unit_label = time_unit_label,
    cluster_heatmap_columns = plot_options[["cluster_heatmap_columns"]]
    )

  # log2_intensity_shape <- plot_log2_intensity_shapes()

  level_headers_info <- list()
  plots <- list()
  plots_sizes <- list()
  q <- 0

  for (i in seq_along(all_levels_clustering)) {

    # When a level has < 2 hits
    if (is.null(all_levels_clustering[[i]]) ||
        all(is.na(all_levels_clustering[[i]]))) {
      next
    } else {
      q <- q + 1
    }

    level_clustering <- all_levels_clustering[[i]]

    levels <- unique(meta[[condition]])

    if (length(levels) >= i) {

      ith_unique_value <- levels[i]

      # Construct header name
      header_name <- ith_unique_value

      nr_hits <- nrow(level_clustering$clustered_hits)

      header_info <- list(
        header_name = header_name,
        nr_hits = nr_hits,
        adj_pvalue_threshold = adj_pthresholds[i]
        )

      level_headers_info[[i]] <- header_info
    }

    curve_values <- level_clustering$curve_values

    dendrogram <- plot_dendrogram(
      hc = level_clustering$hc,
      clusters = level_clustering[["clustered_hits"]][["cluster"]],
      k = clusters[q]
      )

    p_curves <- plot_all_mean_splines(
      curve_values = curve_values,
      plot_info = plot_info
      )

    cluster_mean_splines <- plot_cluster_mean_splines( # Plot for each cluster
      curve_values = curve_values,
      plot_info = plot_info
      )

    top_table <- level_clustering$top_table
    levels <- as.character(unique(meta[[condition]]))

    col_indices <- which(meta[[condition]] == levels[i])

    if (mode == "integrated") {
      data_level <- datas[[i]][, col_indices]
    } else {                                    # mode == "isolated"
      data_level <- datas[[i]]
    }

    meta_level <- meta |> dplyr::filter(.data[[condition]] == levels[i])

    clusters_spline_plots <- list()
    
    for (nr_cluster in unique(stats::na.omit(top_table$cluster))) {

      nr_of_hits <- sum(
        level_clustering$clustered_hits$cluster == nr_cluster,
        na.rm = TRUE
        )
      main_title <- paste(
        "Cluster",
        nr_cluster,
        " | Hits:",
        nr_of_hits, 
        sep = " "
        )

      top_table_cluster <- top_table |>
        dplyr::filter(!!rlang::sym("cluster") == nr_cluster)

      X <- level_clustering$X

      spline_plots <- plot_splines(
        top_table = top_table_cluster,
        data = data_level,
        meta = meta_level,
        X = X,
        time_unit_label = time_unit_label,
        plot_info = plot_info,
        adj_pthreshold = adj_pthresholds[i],
        replicate_column = plot_options[["meta_replicate_column"]]
        )

      clusters_spline_plots[[length(clusters_spline_plots) + 1]] <- list(
        spline_plots = spline_plots,
        cluster_main_title = main_title
        )
    }

    plots <- c(
      plots,
      new_level = "level_header",    # is the signal for the plotting code
      dendrogram = list(dendrogram),
      p_curves = list(p_curves),
      cluster_mean_splines = list(cluster_mean_splines),
      heatmap = heatmaps[[i]],
      individual_spline_plots = clusters_spline_plots  # gets expanded like this
      )

    # For every plot in plots, this determines the size in the HTML
    plots_sizes <- c(
      plots_sizes,
      999,               # dummy size for "next_level" signal
      1.5,
      1.5,
      1,
      1.5,
      rep(1, length(clusters_spline_plots))
      )
  }

  topTables <- list()

  # Loop over each element in all_levels_clustering
  for (i in seq_along(all_levels_clustering)) {
    
    if (is.logical(all_levels_clustering[[i]])) next
    
    # Get the current element, which is a list
    current_element <- all_levels_clustering[[i]]
    
    # Extract the top_table element
    top_table_element <- current_element$top_table
    
    # Get the name of the outer list element
    element_name <- names(all_levels_clustering)[i]
    
    # Trim the name to 30 characters if necessary
    if (nchar(element_name) > 30) {
      element_name <- substr(element_name, 1, 30)
    }
    
    topTables[[element_name]] <- top_table_element
  }
  
  if (!is.null(genes)) {
    enrichr_format <- prepare_gene_lists_for_enrichr(
      all_levels_clustering,
      genes
    )
  } else {
    enrichr_format <- NA
  }
  
  all_levels_clustering <- merge_annotation_all_levels_clustering(
    all_levels_clustering = all_levels_clustering,
    annotation = annotation
  )

  print("Generating report. This takes a few seconds.")

  generate_report_html(
    plots = plots,
    limma_result_2_and_3_plots = spline_comp_plots,
    plots_sizes = plots_sizes,
    level_headers_info = level_headers_info,
    spline_params = spline_params,
    report_info = report_info,
    data = bind_data_with_annotation(data, annotation),
    meta = meta,
    topTables = topTables,
    enrichr_format = enrichr_format,
    adj_pthresholds = adj_pthresholds,
    report_type = "cluster_hits",
    feature_name_columns = feature_name_columns,
    mode = mode,
    filename = "report_clustered_hits",
    report_dir = report_dir
    )

  return(plots)
}


#' Generate spline comparison plots for all condition pairs
#'
#' @description
#' This function generates spline comparison plots for all pairwise 
#' combinations of conditions in the metadata. For each condition pair, it 
#' compares the time effects of two conditions, plots the data points, and 
#' overlays the fitted spline curves. The function only generates plots if 
#' the adjusted p-values for the average difference between conditions and the 
#' interaction between condition and time are below the specified thresholds.
#'
#' @param splineomics A list containing the splineomics results, including
#'  time effects, 
#' average difference between conditions, and interaction between condition 
#' and time.
#' @param all_levels_clustering A list containing the X matrices for each 
#' condition, used 
#' for spline fitting.
#' @param data The data matrix containing the measurements.
#' @param meta The metadata associated with the measurements, which includes
#'  the condition.
#' @param condition Column name of meta that contains the levels of the
#' experiment.
#' @param plot_info A list containing plotting information such as time unit 
#' and axis labels.
#' @param adj_pthresh_avrg_diff_conditions The adjusted p-value threshold for
#'  the average 
#' difference between conditions.
#' @param adj_pthresh_interaction The adjusted p-value threshold for the 
#' interaction 
#' between condition and time.
#' 
#' @return A list of lists containing the comparison plots and feature names
#'         for each condition pair.
#' 
generate_spline_comparisons <- function(
    splineomics,
    all_levels_clustering,  # This list contains the X matrices
    data,
    meta,
    condition,
    plot_info,  
    adj_pthresh_avrg_diff_conditions,  
    adj_pthresh_interaction  
) {
  # Initialize the list that will store the results
  comparison_plots <- list()
  
  # Check if all three elements are present
  if (length(splineomics[['limma_splines_result']]) == 3) {
    # Extract the three named elements
    time_effect <- splineomics[['limma_splines_result']][['time_effect']]
    avrg_diff_conditions <- 
      splineomics[['limma_splines_result']][['avrg_diff_conditions']]
    interaction_condition_time <- 
      splineomics[['limma_splines_result']][['interaction_condition_time']]

    # Get the unique conditions from the meta data
    conditions <- unique(meta[[condition]])
    
    # Generate all pairwise combinations of conditions
    condition_pairs <- utils::combn(conditions, 2, simplify = FALSE)
    
    # Loop over all condition pairs and generate plots
    for (pair in condition_pairs) {
      condition_1 <- pair[1]
      condition_2 <- pair[2]
      
      # Sort the current pair of conditions
      sorted_conditions <- sort(c(condition_1, condition_2))
      
      # Initialize matched dataframes as NULL
      matched_avrg_diff <- NULL
      matched_interaction_cond_time <- NULL
      
      # Search for the correct dataframe in avrg_diff_conditions
      for (df_name in names(avrg_diff_conditions)) {
        # Extract the part after 'avrg_diff_' and split it by '_vs_'
        conditions_in_df <- strsplit(sub(
          "avrg_diff_",
          "",
          df_name
          ),
          "_vs_"
          )[[1]]
        
        sorted_conditions_in_df <- sort(conditions_in_df)
        
        # Check if the sorted conditions in the dataframe match the current pair
        if (identical(sorted_conditions, sorted_conditions_in_df)) {
          matched_avrg_diff <- avrg_diff_conditions[[df_name]]
          break
        }
      }

      # Search for the correct dataframe in interaction_condition_time
      for (df_name in names(interaction_condition_time)) {
        # Extract the part after 'time_interaction_condition_'
        # and split it by '_vs_'
        conditions_in_df <- strsplit(sub(
          "time_interaction_",
          "", 
          df_name
          ),
          "_vs_"
          )[[1]]
        
        sorted_conditions_in_df <- sort(conditions_in_df)
        
        # Check if the sorted conditions in the dataframe match the
        # current pair
        if (identical(sorted_conditions, sorted_conditions_in_df)) {
          matched_interaction_cond_time <- interaction_condition_time[[df_name]]
          break
        }
      }

      # If both matched dataframes are found, generate plots
      if (!is.null(matched_avrg_diff) 
          && !is.null(matched_interaction_cond_time)) {
        # Get the corresponding dataframes from time_effect
        time_effect_1 <- time_effect[[paste0(condition, "_", condition_1)]]
        time_effect_2 <- time_effect[[paste0(condition, "_", condition_2)]]
        
        # Get the respective X matrices from all_levels_clustering
        X_1 <- all_levels_clustering[[paste0(condition, "_", condition_1)]]$X
        X_2 <- all_levels_clustering[[paste0(condition, "_", condition_2)]]$X

        # Call the plot function for this pair and store the result
        plots_and_feature_names <- plot_spline_comparisons(
          time_effect_1 = time_effect_1,
          condition_1 = condition_1,
          time_effect_2 = time_effect_2,
          condition_2 = condition_2,
          avrg_diff_conditions = matched_avrg_diff,
          interaction_condition_time = matched_interaction_cond_time,
          data = data,
          meta = meta,
          condition = condition,
          X_1 = X_1,
          X_2 = X_2,
          plot_info = plot_info,
          adj_pthresh_avrg_diff_conditions = adj_pthresh_avrg_diff_conditions,
          adj_pthresh_interaction = adj_pthresh_interaction
        )
        
        # Add the plot list to the comparison_plots list,
        # naming it by the condition pair
        plot_list_name <- paste0(condition_1, "_vs_", condition_2)
        comparison_plots[[plot_list_name]] <- plots_and_feature_names
      }
    }
  } else {
    message("The required elements are not present in the splineomics list.")
  }
  
  # Return the list containing all plot lists
  return(comparison_plots)
}



#' Clean the Gene Symbols
#'
#' @description
#' This function preprocesses a vector of gene names by cleaning and 
#' formatting them. It removes any non-alphanumeric characters after the 
#' first block of alphanumeric characters and converts the remaining 
#' characters to uppercase.
#'
#' @param genes A character vector containing gene names to be cleaned.
#'
#' @return A character vector of cleaned gene symbols (names) with the same 
#' length as the input. The cleaned names will be in uppercase, and any 
#' invalid or empty gene names will be replaced with NA.
#'
clean_gene_symbols <- function(genes) {
  message(paste0(
    "\033[33m\nGene symbols: Transforming all non-alphanumeric characters to ",
    "whitespace, then extracting the substring of alphanumeric characters ",
    "before the first whitespace or end of the string. The extracted ",
    "substring is then converted to uppercase.\033[0m"
  ))
  
  message(paste0(
    "\033[38;5;214mIf this does not produce valid gene symbols for your gene", 
    "set enrichment analysis, modify ",
    "the genes argument of this function (cluster_hits) accordingly!\033[0m"
  ))
  
  # Apply cleaning process to each gene
  cleaned_genes <- sapply(genes, function(gene_name) {
    if (!is.na(gene_name) && gene_name != "") {
      # Replace all non-alphanumeric characters with whitespace
      gene_name <- gsub("[^A-Za-z0-9]", " ", gene_name)
      
      # Extract the first block of alphanumeric characters before the 
      # first whitespace
      clean_gene_name <- sub("^([A-Za-z0-9]+).*", "\\1", gene_name)
      
      # Convert to uppercase
      toupper(clean_gene_name)
    } else {
      NA
    }
  })
  
  # Return cleaned genes, keeping the same index as input
  return(cleaned_genes)
}


# Level 2 internal functions ---------------------------------------------------


#' Check for Between-Level Patterns in Top Tables
#'
#' @description
#' This function checks if any of the elements within a list of top tables 
#' contain element names that match the specified between-level pattern.
#'
#' @param top_tables A list where each element is itself a list containing 
#' named elements.
#'
#' @return A list with two elements:
#' \describe{
#'   \item{between_levels}{A logical value indicating whether any element names 
#'   match the between-level pattern.}
#'   \item{index_with_pattern}{The index of the first element in `top_tables` 
#'   where all names match the between-level pattern, or NA if no match is 
#'   found.}
#' }
#'
#' @details
#' The function iterates over each element in `top_tables`. For each element 
#' that 
#' is a list, it checks if all names within that inner list match the pattern 
#' `".+_vs_.+"`. If a match is found, the function sets `between_levels` to TRUE 
#' and records the index of the matching element. The search stops at the first 
#' match.
#' 
check_between_level_pattern <- function(top_tables) {

  # Initialize variables
  between_levels <- FALSE
  index_with_pattern <- NA

  # Define the regular expression pattern
  pattern <- ".+_vs_.+"

  # Check if top_tables is a list
  if (is.list(top_tables)) {
    # Iterate over each element in top_tables
    for (i in seq_along(top_tables)) {
      # Check if the element is a list
      if (is.list(top_tables[[i]])) {
        # Get the names of the elements in the inner list
        element_names <- names(top_tables[[i]])
        # Check if all names in the inner list match the pattern
        if (all(grepl(pattern, element_names))) {
          between_levels <- TRUE
          index_with_pattern <- i
          break
        }
      }
    }
  }

  return(list(
    between_levels = between_levels,
    index_with_pattern = index_with_pattern
    ))
}


#' Get Hit Indices for a Specific Level
#'
#' @description
#' This function retrieves unique feature indices from a list of between-level 
#' top tables for a specified level, based on adjusted p-value thresholds.
#'
#' @param between_level_top_tables A list of data frames containing the 
#' between-level top tables.
#' @param level A string specifying the level to search for within the names 
#' of the data frames.
#' @param adj_pthresholds A numeric vector of adjusted p-value thresholds for 
#' each data frame in `between_level_top_tables`.
#'
#' @return A vector of unique feature indices that meet the adjusted p-value 
#' threshold criteria for the specified level.
#'
#' @details
#' The function iterates over each data frame in `between_level_top_tables`. For 
#' each data frame whose name contains the specified level (case insensitive), 
#' it identifies the rows where the adjusted p-value is below the corresponding 
#' threshold. The function then extracts the feature indices from these rows and 
#' compiles a unique list of these indices.
#' 
get_level_hit_indices <- function(
    between_level_top_tables,
    level,
    adj_pthresholds
    ) {

  unique_hit_indices <- c()

  # Loop through the elements of the list
  for (i in seq_along(between_level_top_tables)) {
    # Get the name of the current data frame
    df_name <- names(between_level_top_tables)[i]

    # Check if the name contains the level string case insensitively
    if (grepl(level, df_name, ignore.case = TRUE)) {
      # Get the current data frame
      within_level_top_table <- between_level_top_tables[[i]]

      # Find the row indices that meet the condition
      hit_indices <-
        which(within_level_top_table[["adj.P.Val"]] < adj_pthresholds[i])

      # Extract the feature indices from the identified rows
      feature_indices <- within_level_top_table[hit_indices, "feature_nr"]
      feature_indices <- within_level_top_table[hit_indices,
                                                "feature_nr", drop = TRUE]
      unique_hit_indices <- c(
        unique_hit_indices,
        feature_indices
        )
    }
  }

  # Get unique feature indices
  unique_hit_indices <- unique(unique_hit_indices)
}


#' Process Level Cluster
#'
#' @description
#' Processes clustering for a specific level within a condition using the
#' provided top table and spline parameters.
#'
#' @param top_table A dataframe containing the top table results from limma.
#' @param cluster_size The size of clusters to generate.
#' @param level The level within the condition to process.
#' @param meta A dataframe containing metadata.
#' @param condition A character string specifying the condition.
#' @param spline_params A list of spline parameters for the analysis.
#' @param mode A character string specifying the mode
#'            ('isolated' or 'integrated').
#'
#' @return A list containing the clustering results, including curve values and
#'         the design matrix.
#'
#' @seealso
#' \code{\link{get_curve_values}}, \code{\link{normalize_curves}},
#' \code{\link{hierarchical_clustering}}
#'
process_level_cluster <- function(
    top_table,
    cluster_size,
    level,
    meta,
    condition,
    spline_params,
    mode
    ) {

  # means that it had < 2 hits.
  if (is.null(top_table) || all(is.na(top_table))) {
    return(NA)
  }
  
  curve_results <- get_curve_values(
    top_table = top_table,
    level = level,
    meta = meta,
    condition = condition,
    spline_params = spline_params,
    mode = mode
    )

  normalized_curves <- normalize_curves(curve_results$curve_values)

  clustering_result <-
    hierarchical_clustering(
      curve_values = normalized_curves,
      k = cluster_size,
      smooth_timepoints = curve_results$smooth_timepoints,
      top_table = top_table
      )

  clustering_result$X <- curve_results$X
  return(clustering_result)
}


#' Remove Batch Effect from Cluster Hits
#'
#' @description
#' This function removes batch effects from the data for each level specified 
#' by the condition. It supports both isolated and integrated modes, with 
#' optional handling for a second batch column.
#'
#' @param data A dataframe containing the main data.
#' @param meta A dataframe containing meta information.
#' @param condition A string specifying the column in `meta` that divides the 
#' experiment into levels.
#' @param meta_batch_column A string specifying the column in `meta` that 
#' indicates batch information.
#' @param meta_batch2_column A string specifying the second batch column in 
#' `meta`, if applicable.
#' @param design A design matrix for the experiment.
#' @param mode A string indicating the mode of operation: "isolated" or 
#' "integrated".
#' @param spline_params A list of spline parameters for the design matrix.
#'
#' @return A list of dataframes with batch effects removed for each level.
#'
#' @details
#' The function operates in two modes:
#' \describe{
#'   \item{isolated}{Processes each level independently, using only data from 
#'   that level.}
#'   \item{integrated}{Processes the entire dataset together.}
#' }
#' If `meta_batch_column` is specified, the function removes batch effects using 
#' `removeBatchEffect`. If a second batch column (`meta_batch2_column`) is 
#' specified, it is also included in the batch effect removal.
#'
#' @importFrom limma removeBatchEffect
#' 
remove_batch_effect_cluster_hits <- function(
    data,
    meta,
    condition,
    meta_batch_column,
    meta_batch2_column,
    design,
    mode,
    spline_params
    ) {

  datas <- list()
  n <- length(unique(meta[[condition]]))
  level_indices <- as.integer(1:n)
  unique_levels <- unique(meta[[condition]])

  if (!is.null(meta_batch_column)) {

    for (level_index in level_indices) {

      # Take only the data from the level for mode == "isolated"
      if (mode == "isolated") {
        level <- unique_levels[level_index]
        level_columns <- which(meta[[condition]] == level)
        data_copy <- data[, level_columns]
        meta_copy <- subset(meta, meta[[condition]] == level)
      } else {
        data_copy <- data   # Take the full data for mode == "integrated"
        meta_copy <- meta
        level_index <- 1L   # spline_params here has only one set of params
      }

      design_matrix <- design2design_matrix(
        meta = meta_copy,
        spline_params = spline_params,
        level_index = level_index,
        design = design
        )

      # The batch columns are not allowed to be in the design_matrix for
      # removeBatchEffect. Instead the batch column is specified with batch =
      batch_columns <- grep(
        paste0(
          "^",
          meta_batch_column
          ),
        colnames(design_matrix)
        )
      
      design_matrix <- design_matrix[, -batch_columns]

      args <- list(
        x = data_copy,
        batch = meta_copy[[meta_batch_column]],
        design = design_matrix
      )
      
      if (mode == "isolated") {
        
        level <- unique_levels[level_index]
        meta_copy <- subset(meta, meta[[condition]] == level)
        
        if (!is.null(meta_batch2_column) &&
            length(unique(meta_copy[[meta_batch2_column]])) > 1) {
          args$batch2 <- meta_copy[[meta_batch2_column]]
        }
      } else {   # mode == integrated
        
        if (!is.null(meta_batch2_column) &&
            length(unique(meta_copy[[meta_batch2_column]])) > 1) {
          args$batch2 <- meta_copy[[meta_batch2_column]]
        }
      }

      data_copy <- do.call(limma::removeBatchEffect, args)

      # For mode == "integrated", all elements are identical
      datas <- c(datas, list(data_copy))
    }

  } else {          # no meta batch column specified, just return right data

    for (level_index in level_indices) {

      # Take only the data from the level for mode == "isolated"
      if (mode == "isolated") {
        level <- unique_levels[level_index]
        level_columns <- which(meta[[condition]] == level)
        data_copy <- data[, level_columns]
      } else {
        data_copy <- data   # Take the full data for mode == "integrated"
      }

      datas <- c(datas, list(data_copy))
    }
  }
  return(datas)
}


#' Plot Heatmap
#'
#' @description
#' Generates heatmaps for each level within a condition, showing z-scores of
#' log2 intensity values, split by clusters.
#'
#' @param datas A matrix of data values.
#' @param meta A dataframe containing metadata.
#' @param mode A character vector with length 1, specifying the type of limma
#'             design formula (integrated for formulas with interaction effects
#'             between the levels, isolated for formulas where each level is 
#'             analysed in isolation (no interaction effects))
#' @param condition A character string specifying the condition.
#' @param all_levels_clustering A list containing clustering results for each
#' level within the condition.
#' @param time_unit_label A character string specifying the time unit label.
#' @param cluster_heatmap_columns Boolean specifying wether to cluster the 
#' columns of the heatmap or not.
#'
#' @return A list of ComplexHeatmap heatmap objects for each level.
#'
#' @seealso
#' \link[ComplexHeatmap]{Heatmap}, \link[dplyr]{arrange}
#'
#' @importFrom dplyr arrange mutate group_by summarize
#' @importFrom tidyr pivot_longer separate
#' @importFrom ComplexHeatmap Heatmap draw ht_opt
#' @importFrom ggplot2 ggplot geom_line facet_wrap geom_vline ylab theme unit
#' @importFrom ggplot2 theme_bw scale_x_continuous
#' @importFrom grid gpar
#'
plot_heatmap <- function(
    datas,
    meta,
    mode,
    condition,
    all_levels_clustering,
    time_unit_label,
    cluster_heatmap_columns
    ) {

  BASE_TEXT_SIZE_PT <- 5

  ht_opt(
    simple_anno_size = unit(1.5, "mm"),
    COLUMN_ANNO_PADDING = unit(1, "pt"),
    DENDROGRAM_PADDING = unit(1, "pt"),
    HEATMAP_LEGEND_PADDING = unit(1, "mm"),
    ROW_ANNO_PADDING = unit(1, "pt"),
    TITLE_PADDING = unit(2, "mm"),
    heatmap_row_title_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    heatmap_row_names_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    heatmap_column_title_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    heatmap_column_names_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    legend_labels_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    legend_title_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    legend_border = FALSE
  )
  
  ht_opt$message = FALSE

  levels <- unique(meta[[condition]])
  heatmaps <- list()
  
  # Generate a heatmap for every level
  for (i in seq_along(all_levels_clustering)) {

    # When a level has < 2 hits
    if (is.null(all_levels_clustering[[i]]) ||
        all(is.na(all_levels_clustering[[i]]))) {
      heatmaps[[length(heatmaps) + 1]] <- NA
      next
    }

    level_clustering <- all_levels_clustering[[i]]

    clustered_hits <- level_clustering$clustered_hits
    clusters <- clustered_hits |> dplyr::arrange(!!rlang::sym("cluster"))

    level <- levels[[i]]
    level_indices <- which(meta[[condition]] == level)

    if (mode == "integrated") {
      data_level <- datas[[i]][, level_indices]
    } else {                                    # mode == "isolated"
      data_level <- datas[[i]]
    }

    data_level <- data_level[as.numeric(clusters$feature),]
    z_score <- t(scale(t(data_level)))

    meta_level <- meta[level_indices, ]
    
    row_labels <- truncate_row_names(rownames(data_level))

    ht <-
      ComplexHeatmap::Heatmap(
        z_score,
        name = paste0(
          "left-labels = cluster,", 
          "top-labels = time"
          ),
        use_raster = TRUE,
        column_split = meta_level$Time,
        cluster_columns = cluster_heatmap_columns,
        row_split = clusters$cluster,
        cluster_rows = FALSE,
        heatmap_legend_param = list(
          title = "z-score of log2 values",
          title_position = "lefttop-rot"
          ),
        row_gap = unit(2, "pt"),
        column_gap = unit(2, "pt"),
        # width = unit(2, "mm") * ncol(z_score) +
        #   5 * unit(2, "pt"),
        # height = unit(2, "mm") * nrow(z_score) +
        #   5 * unit(2, "pt"),
        show_row_names = TRUE,
        row_labels = row_labels,
        show_column_names = TRUE,
        column_names_rot = 70,
        column_names_gp = gpar(fontsize = 5))

    heatmaps[[length(heatmaps) + 1]] <- ht
  }
  heatmaps
}


#' Plot Dendrogram
#'
#' @description
#' Generates a dendrogram plot for hierarchical clustering results,
#' colored by clusters.
#'
#' @param hc A hierarchical clustering object.
#' @param clusters A numeric vector, specifying the cluster in which each hit is
#' in. Index 1 is the cluster of hit nr. 1, index 2 of hit nr. 2, etc.
#' @param k An integer specifying the number of clusters.
#'
#' @return A ggplot object representing the dendrogram.
#'
#' @seealso
#' \link[dendextend]{color_branches}, \link[dendextend]{as.ggdend},
#' \link[ggplot2]{ggplot2}
#'
#' @importFrom stats as.dendrogram cutree
#' @importFrom dendextend color_branches as.ggdend
#' @importFrom ggplot2 ggplot element_blank labs theme_minimal theme
#'
plot_dendrogram <- function(
    hc,
    clusters,
    k
) {

  # Convert hc to dendrogram
  dend <- stats::as.dendrogram(hc)

  # Get clusters based on cutree result
  clusters <- stats::cutree(hc, k)

  # Get the order of clusters as they appear in the dendrogram
  cluster_order <- clusters[hc[["order"]]]

  # Find the unique clusters in the order they appear in the dendrogram
  unique_cluster_order <- unique(cluster_order)

  # Generate distinct colors for the k clusters
  colors <- scales::hue_pal()(k)

  # Reorder the colors according to the appearance of clusters in the dendrogram
  ordered_colors <- colors[match(
    unique_cluster_order,
    sort(unique(clusters))
    )]

  # Apply the reordered colors to the branches of the dendrogram
  dend_colored <- dendextend::color_branches(
    dend,
    k = k,
    col = ordered_colors
  )

  # Remove labels for the plot
  dend_colored <- dendextend::set(
    dend_colored,
    "labels",
    value = rep(
      "",
      length(dendextend::get_leaves_attr(dend_colored, "label"))
    )
  )

  # Convert to ggplot-compatible dendrogram
  ggdend <- dendextend::as.ggdend(dend_colored)

  # Create the plot
  p_dend <- ggplot2::ggplot(ggdend) +
    ggplot2::labs(
      title = paste(
        "Hierarchical Clustering Dendrogram Features (colors = clusters",
        "(see legend plot below!))"
      ),
      x = "",
      y = ""
    ) +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      axis.text.x = ggplot2::element_blank(),
      axis.ticks.x = ggplot2::element_blank(),
      axis.text.y = ggplot2::element_blank(),
      axis.ticks.y = ggplot2::element_blank(),
      plot.title = ggplot2::element_text(size = 9)
    )

  return(p_dend)
}


#' Plot All Mean Splines
#'
#' @description
#' Generates a plot of average curves for each cluster, showing min-max
#' normalized intensities over time.
#'
#' @param curve_values A dataframe containing curve values and cluster
#' assignments.
#' @param plot_info List containing the elements y_axis_label (string), 
#'                  time_unit (string), treatment_labels (character vector),
#'                  treatment_timepoints (integer vector). All can also be NA. 
#'                  This list is used to add this info to the spline plots. 
#'                  time_unit is used to label the x-axis, and treatment_labels
#'                  and -timepoints are used to create vertical dashed lines,
#'                  indicating the positions of the treatments (such as 
#'                  feeding, temperature shift, etc.).
#'
#' @return A ggplot object representing the average curves by cluster.
#'
#' @importFrom scales hue_pal
#' @importFrom ggplot2 ggplot geom_line ggtitle xlab ylab scale_color_brewer
#'                     theme_minimal aes element_text
#' @importFrom rlang .data
#'
plot_all_mean_splines <- function(
    curve_values,
    plot_info
    ) {

  time <- as.numeric(colnames(curve_values)[-length(colnames(curve_values))])

  clusters <- unique(curve_values$cluster)
  average_curves <- data.frame()

  # Loop through each unique cluster value to calculate the average curve
  for (current_cluster in clusters) {
    # Filter rows for the current cluster
    subset_hits <- curve_values[curve_values$cluster == current_cluster, ]
    last_timepoint <- (which(names(curve_values) == "cluster")) - 1
    average_curve <- colMeans(subset_hits[,1:last_timepoint])

    # Create a data frame for the average curve with an additional 'Cluster'
    # column
    curve_df <- data.frame(
      Time = time, Value = average_curve,
      cluster = as.factor(current_cluster)
      )

    # Bind the curve data frame to the cumulative data frame
    average_curves <- rbind(
      average_curves,
      curve_df
      )
  }

  average_curves$cluster <- factor(
    average_curves$cluster,
    levels = sort(
      unique(as.numeric(average_curves$cluster)))
    )
  
  time_unit_label = paste0("[", plot_info$time_unit, "]")
  
  cluster_colors <- scales::hue_pal()(length(unique(average_curves$cluster)))
  
  if (length(cluster_colors) > length(unique(average_curves$cluster))) {
    cluster_colors <- cluster_colors[1:length(unique(average_curves$cluster))]
  }
  names(cluster_colors) <- paste(
    "Cluster",
    levels(average_curves$cluster)
    )
  
  color_values <- c(cluster_colors)
  distinct_colors <- c()
  
  # Create the base plot
  p_curves <- ggplot2::ggplot(
    average_curves,
    ggplot2::aes(
      x = !!rlang::sym("Time"),
      y = !!rlang::sym("Value"),
      color = paste("Cluster", factor(!!rlang::sym("cluster")))
    )
  ) +
    ggplot2::geom_line() +
    ggplot2::ggtitle("Average Splines by Cluster") +
    ggplot2::xlab(paste("Time", time_unit_label)) +
    ggplot2::ylab(paste("min-max norm.", plot_info$y_axis_label)) +
    ggplot2::theme_minimal() +
    ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5))
  
  # Conditionally add vertical dashed lines if treatment_labels is not NA
  if (!all(is.na(plot_info$treatment_labels))) {
    # Create a data frame for the treatment lines
    treatment_df <- data.frame(
      Time = plot_info$treatment_timepoints,
      Label = plot_info$treatment_labels
    )
    
    p_curves <- p_curves +
      ggplot2::geom_vline(
        data = treatment_df, 
        ggplot2::aes(xintercept = .data$Time, color = .data$Label), 
        linetype = "dashed", 
        size = 0.5
      ) +
      ggplot2::geom_text(
        data = treatment_df,
        ggplot2::aes(
          # Slightly offset from the vertical line
          x = .data$Time - max(.data$Time) * 0.005,  
          y = 1,  # Place the labels at the top of the plot
          label = .data$Time,
          color = .data$Label
        ),  
        angle = 90,  # Rotate the labels
        vjust = 0,  # Position on the left side of the dashed line
        hjust = 1,  
        size = 3,  # Text size
        show.legend = FALSE  # Prevent text labels from appearing in the legend
      )
    
    treatment_labels <- na.omit(plot_info$treatment_labels)
    distinct_colors <- scales::hue_pal()(length(treatment_labels))
    names(distinct_colors) <- treatment_labels
    color_values <- c(
      cluster_colors,
      distinct_colors
      )
  }
  
  # Finalize color scale and theme adjustments
  p_curves <- p_curves +
    ggplot2::scale_color_manual(
      values = color_values,
      name = ggplot2::element_text("Cluster/Treatment"),
      guide = ggplot2::guide_legend(
        override.aes = list(
          linetype = c(rep("solid", length(cluster_colors)),
                       rep("dashed", length(distinct_colors))),
          size = c(rep(1, length(cluster_colors)),
                   rep(0.5, length(distinct_colors)))  
        )
      )
    ) +
    ggplot2::theme(
      legend.key.size = grid::unit(0.6, "cm"),  
      legend.key.height = grid::unit(0.3, "cm"),
      legend.title = ggplot2::element_text(size = 8) 
    )

  return(p_curves)
}


#' Plot Consensus Shapes
#'
#' @description
#' Generates composite plots of single and consensus shapes for each cluster
#' of curve values.
#'
#' @param curve_values A dataframe containing curve values and cluster
#'  assignments.
#' @param plot_info List containing the elements y_axis_label (string), 
#'                  time_unit (string), treatment_labels (character vector),
#'                  treatment_timepoints (integer vector). All can also be NA. 
#'                  This list is used to add this info to the spline plots. 
#'                  time_unit is used to label the x-axis, and treatment_labels
#'                  and -timepoints are used to create vertical dashed lines,
#'                  indicating the positions of the treatments (such as 
#'                  feeding, temperature shift, etc.).
#'
#' @return A list containing a plot for every cluster
#'
#' @seealso
#' \code{\link{plot_single_and_mean_splines}}
#'
plot_cluster_mean_splines <- function(
    curve_values,
    plot_info
    ) {

  clusters <- sort(unique(curve_values$cluster))

  plots <- list()
  for (current_cluster in clusters) {
    subset_df <- subset(
      curve_values,
      curve_values$cluster == current_cluster
      )
    subset_df$cluster <- NULL
    nr_of_hits <- nrow(subset_df)
    current_title <- paste(
      "Cluster",
      current_cluster, 
      "| Hits:",
      nr_of_hits,
      sep = " "
      )

    plots[[length(plots) + 1]] <-
      plot_single_and_mean_splines(
        subset_df,
        current_title,
        plot_info = plot_info
        )
  }
  
  return(plots)
}


#' Plot Splines for Features Based on Top Table Information
#'
#' @description This function generates plots for each feature listed in the
#' top table using spline
#' interpolation for fitted values. It creates individual plots for each feature
#' and combines
#' them into a single composite plot. The function is internal and not exported.
#'
#' @param top_table A dataframe containing the indices and names of features,
#' along with their
#'                  statistical metrics such as intercepts and spline
#'                  coefficients.
#' @param data A matrix or dataframe containing the raw data values for each
#' feature.
#' @param meta A dataframe containing metadata for the data, including time
#' points.
#' @param X The limma design matrix that defines the experimental conditions.
#' @param time_unit_label A string shown in the plots as the unit for the time,
#' such as min or hours.
#' @param plot_info List containing the elements y_axis_label (string), 
#'                  time_unit (string), treatment_labels (character vector),
#'                  treatment_timepoints (integer vector). All can also be NA. 
#'                  This list is used to add this info to the spline plots. 
#'                  time_unit is used to label the x-axis, and treatment_labels
#'                  and -timepoints are used to create vertical dashed lines,
#'                  indicating the positions of the treatments (such as 
#'                  feeding, temperature shift, etc.).
#' @param adj_pthreshold Double > 0 and < 1 specifying the adj. p-val threshold.
#' @param replicate_column String specifying the column of the meta dataframe
#' that contains the labels of the replicate measurents. When that is not 
#' given, this argument is NULL.
#'
#' @return A list containing the composite plot and the number of rows used in
#' the plot layout.
#'
#' @importFrom splines ns
#' @importFrom ggplot2 ggplot geom_point geom_line theme_minimal labs theme
#' scale_x_continuous annotate
#' @importFrom patchwork wrap_plots plot_annotation
#' @importFrom scales hue_pal
#' @importFrom rlang .data
#'
plot_splines <- function(
    top_table,
    data,
    meta,
    X,   
    time_unit_label,
    plot_info,
    adj_pthreshold,
    replicate_column
) {
  
  # Sort so that HTML reports are easier to read and comparisons are easier.
  top_table <- top_table |> dplyr::arrange(.data$feature_names)
  
  DoF <- which(names(top_table) == "AveExpr") - 1
  time_points <- meta$Time
  
  titles <- data.frame(
    FeatureID = top_table$feature_nr,
    feature_names = top_table$feature_names
  )
  
  plot_list <- list()
  
  for (hit in 1:nrow(top_table)) {
    hit_index <- as.numeric(top_table$feature_nr[hit])
    y_values <- data[hit_index, ]
    
    intercept <- top_table$intercept[hit]
    spline_coeffs <- as.numeric(top_table[hit, 1:DoF])
    
    Time <- seq(
      meta$Time[1],
      meta$Time[length(meta$Time)],
      length.out = 1000   # To ensure smoothness of the curve
    )
    
    fitted_values <- X %*% spline_coeffs + intercept
    
    plot_data <- data.frame(
      Time = time_points,
      Y = y_values
    )
    
    # If replicate_column is specified (i.e., a string), use replicate info
    if (!is.null(replicate_column) && is.character(replicate_column)) {
      replicates <- meta[[replicate_column]]  # Get the replicate information
      plot_data$Replicate <- replicates  # Add replicate info to plot data
      
      # Create color palette for replicates
      replicate_colors <- scales::hue_pal()(length(unique(replicates)))
      names(replicate_colors) <- unique(replicates)
      
      color_values <- c("Spline" = "red", replicate_colors)
    } else {
      color_values <- c("Data" = "blue", "Spline" = "red")
    }
    
    treatment_labels <- plot_info$treatment_labels 
    treatment_times <- plot_info$treatment_timepoints 
    
    distinct_colors <- scales::hue_pal()(length(treatment_labels))
    names(distinct_colors) <- treatment_labels
    color_values <- c(color_values, distinct_colors)
    
    # Get adjusted p-value and significance stars
    adj_p_value <- as.numeric(top_table[hit, "adj.P.Val"])
    significance_stars <- ifelse(
      adj_p_value < adj_pthreshold / 50,
      "***",
      ifelse(
        adj_p_value < adj_pthreshold / 5,
        "**",
        ifelse(
          adj_p_value < adj_pthreshold,
          "*",
          ""
        )
      )
    )
    
    # Use local environment to avoid unwanted updating dynamic legend label.
    p <- local({
      spline_label <- paste0(
        "Spline\n(adj. p-val:\n",
        round(adj_p_value, 4),
        "\nAsterisk: ",
        significance_stars,
        ")"
      )
      
      plot_spline <- data.frame(
        Time = Time,
        Fitted = fitted_values
      )
      
      x_max <- as.numeric(max(time_points))
      x_extension <- x_max * 0.05
      
      all_time_points <- unique(c(time_points))
      
      # Filter out close labels to avoid overlapping.
      time_diffs <- diff(all_time_points)
      min_spacing <- x_max * 0.05  # keep all that are more than 5% apart.
      keep_labels <- c(TRUE, time_diffs > min_spacing)
      filtered_time_points <- all_time_points[keep_labels]
      
      dynamic_label <- function(labels) {
        return(ifelse(
          labels == "Spline",
          spline_label,
          labels
        ))
      }
      
      p <- ggplot2::ggplot() +
        ggplot2::geom_point(
          data = plot_data, 
          ggplot2::aes(
            x = Time, 
            y = .data$Y,
            color = if (!is.null(replicate_column) 
                        && is.character(replicate_column)) {
              .data$Replicate
            } else {
              "Data"
            }
          ),
          alpha = 0.5  # 50% transparent data dots
        ) +
        ggplot2::geom_line(
          data = plot_spline, 
          ggplot2::aes(
            x = .data$Time, 
            y = .data$Fitted, 
            color = "Spline"
          )
        ) +
        ggplot2::theme_minimal() +
        ggplot2::scale_x_continuous(
          limits = c(min(time_points), x_max + x_extension),
          breaks = filtered_time_points,  
          labels = function(x) {
            x
          }
        ) +
        ggplot2::labs(
          x = paste0("Time ", time_unit_label), 
          y = plot_info$y_axis_label
        ) +
        ggplot2::scale_color_manual(
          values = color_values,
          labels = dynamic_label
        ) +
        ggplot2::theme(
          legend.position = "right", 
          legend.justification = "center",
          legend.box = "vertical",   
          legend.background = ggplot2::element_blank(),  
          legend.title = ggplot2::element_blank(),  
          legend.text = ggplot2::element_text(
            size = 6, 
            margin = ggplot2::margin(t = 4, b = 4)
          ),
          axis.text.x = ggplot2::element_text(
            size = 8, 
            angle = 45,   # Tilt labels by 45 degrees
            hjust = 1     # Adjust horizontal justification
          ),
          axis.title.y = ggplot2::element_text(
            size = 8, 
            margin = ggplot2::margin(t = 0, r = 2, b = 0, l = 0)
          ),
          axis.text.y = ggplot2::element_text(
            margin = ggplot2::margin(t = 0, r = 5, b = 0, l = 0)
          )
        )
      
      if (!all(is.na(treatment_labels))) {
        # Create a data frame for the treatment lines
        treatment_df <- data.frame(
          Time = treatment_times,
          Label = treatment_labels
        )
        
        p <- p + ggplot2::geom_vline(
          data = treatment_df, 
          ggplot2::aes(
            xintercept = .data$Time, 
            color = .data$Label
          ), 
          linetype = "dashed", 
          size = 0.5
        )
        
        plot_build <- ggplot2::ggplot_build(p)
        y_range <- plot_build$layout$panel_params[[1]]$y.range
        
        # Calculate a y-position slightly below the top of the y-axis range
        y_position <- y_range[2] + diff(y_range) * 0.03  
        
        
        # Add the geom_text for treatment labels at the top of the y-axis
        p <- p + ggplot2::geom_text(
          data = treatment_df,
          ggplot2::aes(
            x = Time - max(Time) * 0.005,  # Slightly offset from vertical line
            y = y_position,  # Uniform y position just above the max y value
            label = .data$Time,
            color = .data$Label
          ),
          angle = 90,  # Rotate the labels
          vjust = 0,  # Position on the left side of the dashed line
          hjust = 1,  # Align the right side of text with the adjusted x pos
          size = 3,  # Text size
          show.legend = FALSE  # Stop text labels from appearing in the legend
        )
      }
      
      # Add title and annotations
      matched_row <- dplyr::filter(
        titles, 
        !!rlang::sym("FeatureID") == hit_index
      )
      
      title <- as.character(matched_row$feature_name)
      
      if (nchar(title) > 100) {
        title_before <- title
        title <- paste0(substr(title, 1, 100), " ...")
        message(paste("The feature ID", title_before, "is > 100 characters.",
                      "Truncating it to 100 chars:", title))
      }
      
      if (is.na(title)) {
        title <- paste("feature:", hit_index)
      }
      
      p <- p + ggplot2::labs(title = title) +
        ggplot2::theme(
          plot.title = ggplot2::element_text(size = 6),
          axis.title.x = ggplot2::element_text(size = 8),
          axis.title.y = ggplot2::element_text(size = 8)
        ) +
        ggplot2::annotate(
          "text",
          x = x_max + (x_extension / 2),
          y = max(fitted_values, na.rm = TRUE),
          label = "",
          hjust = 0.5,
          vjust = 1,
          size = 3.5,
          angle = 0,
          color = "black"
        )
      p
    })
    
    plot_list[[hit]] <- p
  }
  
  return(plot_list)
}


#' Create spline comparison plots for two conditions
#'
#' @description
#' This function generates comparison plots for spline fits of two conditions 
#' over time. It compares the time effects of two conditions, plots the data 
#' points, and overlays the fitted spline curves. The function checks if the 
#' adjusted p-values for the average difference between conditions and the 
#' interaction between condition and time are below the specified thresholds 
#' before generating plots.
#'
#' @param time_effect_1 A data frame containing the time effects for the first
#'  condition.
#' @param condition_1 The name of the first condition.
#' @param time_effect_2 A data frame containing the time effects for the second
#'  condition.
#' @param condition_2 The name of the second condition.
#' @param avrg_diff_conditions A data frame with the adjusted p-values for the
#'  average difference 
#' between conditions.
#' @param interaction_condition_time A data frame with the adjusted p-values
#'  for the interaction between 
#' condition and time.
#' @param data The data matrix containing the measurements.
#' @param meta The metadata associated with the measurements.
#' @param condition Column name of meta that contains the levels of the
#' experiment.
#' @param X_1 A matrix of spline basis values for the first condition.
#' @param X_2 A matrix of spline basis values for the second condition.
#' @param plot_info A list containing plotting information such as time unit 
#' and axis labels.
#' @param adj_pthresh_avrg_diff_conditions The adjusted p-value threshold for 
#' the average difference 
#' between conditions.
#' @param adj_pthresh_interaction The adjusted p-value threshold for the 
#' interaction between 
#' condition and time.
#' 
#' @return A list containing:
#' \describe{
#'   \item{plots}{A list of ggplot2 plots comparing the two conditions.}
#'   \item{feature_names}{A list of feature names for the plotted features.}
#' }
#' 
#' @importFrom rlang .data
#' 
plot_spline_comparisons <- function(
    time_effect_1,
    condition_1,
    time_effect_2,
    condition_2,
    avrg_diff_conditions,
    interaction_condition_time,
    data,
    meta,
    condition,
    X_1,
    X_2,
    plot_info,
    adj_pthresh_avrg_diff_conditions,
    adj_pthresh_interaction
) {

  # Sort and prepare data
  time_effect_1 <- time_effect_1 |> dplyr::arrange(.data$feature_names)
  time_effect_2 <- time_effect_2 |> dplyr::arrange(.data$feature_names)

  # Get relevant parameters
  DoF <- which(names(time_effect_1) == "AveExpr") - 1
  time_points <- meta$Time
  titles <- data.frame(
    FeatureID = time_effect_1$feature_nr,
    feature_names = time_effect_1$feature_names
  )

  plot_list <- list()
  feature_names_list <- list()

  for (hit in 1:nrow(time_effect_1)) {
    hit_index <- as.numeric(time_effect_1$feature_nr[hit])
    y_values_1 <- data[hit_index, ]
    y_values_2 <- data[hit_index, ]

    intercept_1 <- time_effect_1$intercept[hit]
    intercept_2 <- time_effect_2$intercept[hit]

    spline_coeffs_1 <- as.numeric(time_effect_1[hit, 1:DoF])
    spline_coeffs_2 <- as.numeric(time_effect_2[hit, 1:DoF])

    Time <- seq(meta$Time[1], meta$Time[length(meta$Time)], length.out = 1000)
    fitted_values_1 <- X_1 %*% spline_coeffs_1 + intercept_1
    fitted_values_2 <- X_2 %*% spline_coeffs_2 + intercept_2

    # Get the adjusted p-values for the current hit
    avrg_diff_pval <- as.numeric(avrg_diff_conditions[hit, "adj.P.Val"])
    interaction_pval <- as.numeric(interaction_condition_time[hit, "adj.P.Val"])

    if (avrg_diff_pval < adj_pthresh_avrg_diff_conditions
        || interaction_pval < adj_pthresh_interaction) {
      
      # Define the number of stars for avrg_diff_conditions
      avrg_diff_stars <- ifelse(
        avrg_diff_pval < adj_pthresh_avrg_diff_conditions / 50, 
        "***", 
        ifelse(
          avrg_diff_pval < adj_pthresh_avrg_diff_conditions / 5, 
          "**", 
          ifelse(
            avrg_diff_pval < adj_pthresh_avrg_diff_conditions, 
            "*", 
            ""
          )
        )
      )
      
      # Define the number of stars for interaction_condition_time
      interaction_stars <- ifelse(
        interaction_pval < adj_pthresh_interaction / 50, 
        "***", 
        ifelse(
          interaction_pval < adj_pthresh_interaction / 5, 
          "**", 
          ifelse(
            interaction_pval < adj_pthresh_interaction, 
            "*", 
            ""
          )
        )
      )

      # Use the conditions to split the data points
      plot_data <- data.frame(
        Time = time_points,
        Y1 = ifelse(meta[[condition]] == condition_1, y_values_1, NA),
        Y2 = ifelse(meta[[condition]] == condition_2, y_values_2, NA)
      )

      # Create the plot
      p <- ggplot2::ggplot() +
        ggplot2::geom_point(
          data = plot_data,
          ggplot2::aes(
            x = .data$Time,
            y = .data$Y1,
            color = paste("Data", condition_1)
            ),
          na.rm = TRUE,
          alpha = 0.5  # Make data dots transparent
        ) +
        ggplot2::geom_line(
          data = data.frame(
            Time = Time,
            Fitted = fitted_values_1
            ),
          ggplot2::aes(
            x = .data$Time,
            y = .data$Fitted,
            color = paste("Spline", condition_1)
            )
        ) +
        ggplot2::geom_point(
          data = plot_data,
          ggplot2::aes(
            x = .data$Time,
            y = .data$Y2,
            color = paste("Data", condition_2)
            ),
          na.rm = TRUE,
          alpha = 0.5  # Make data dots transparent
        ) +
        ggplot2::geom_line(
          data = data.frame(
            Time = Time,
            Fitted = fitted_values_2
            ),
          ggplot2::aes(
            x = .data$Time,
            y = .data$Fitted,
            color = paste("Spline", condition_2)
            )
        ) +
        ggplot2::scale_color_manual(values = setNames(
          c("orange", "orange", "purple", "purple"),
          c(paste("Data", condition_1), paste("Spline", condition_1),
            paste("Data", condition_2), paste("Spline", condition_2))
        )) +
        ggplot2::scale_x_continuous(
          breaks = unique(meta$Time),  # Labels are placed at data points 
          guide = ggplot2::guide_axis(
            angle = 45,         # Tilt the labels 45 degrees
            n.dodge = 2         # Prevent overlapping by dodging labels
          )
        ) +
        ggplot2::labs(
          title = paste(
            "\nadj.P.Val avrg_diff_conditions: ",
            round(avrg_diff_conditions[hit, "adj.P.Val"], 4),
            avrg_diff_stars,
            "\nadj.P.Val interaction_condition_time: ",
            round(interaction_condition_time[hit, "adj.P.Val"], 4),
            interaction_stars
          ),
          x = paste0("Time [", plot_info$time_unit, "]"),
          y = plot_info$y_axis_label
        ) +
        ggplot2::theme_minimal() +
        ggplot2::theme(
          legend.position = "right",
          legend.title = element_blank(),
          plot.title = ggplot2::element_text(size = 7)
        )

      plot_list[[length(plot_list) + 1]] <- p
      feature_names_list[[length(feature_names_list) + 1]] <-
        as.character(titles$feature_names[hit])
    }
  }

  return(list(
    plots = plot_list,
    feature_names = feature_names_list
  ))
}


#' Merge Annotation with All Top Tables
#'
#' @description
#' This function merges annotation information into the `top_table` of each
#' non-logical element in a list.
#'
#' @param all_levels_clustering A list where each element contains a `top_table`
#' dataframe with a `feature_nr` column. Some elements may be logical values.
#' @param annotation A dataframe containing the annotation information.
#'
#' @return A list with updated `top_table` dataframes containing merged 
#' annotation information.
#'
merge_annotation_all_levels_clustering <- function(
    all_levels_clustering,
    annotation = NULL
) {
  
  all_levels_clustering <- lapply(
    all_levels_clustering,
    function(x) {
      # Check if x is not logical and annotation is not NULL
      if (!is.logical(x) && !is.null(annotation)) {
        x$top_table <- merge_top_table_with_annotation(
          x$top_table,
          annotation
        )
      }
      return(x)
    }
  )
  
  return(all_levels_clustering)
}


#' Prepare Gene Lists for Enrichr and Return as String
#'
#' @description
#' This function processes the clustered hits in each element of 
#' `all_levels_clustering`, formats the gene names for easy copy-pasting into 
#' Enrichr, and returns the formatted gene lists as a string.
#'
#' @param all_levels_clustering A list where each element contains a dataframe
#' `clustered_hits` with columns `feature` and `cluster`.
#' @param genes A vector of gene names corresponding to the feature indices.
#'
#' @return A character vector with the formatted gene lists for each cluster.
#'
prepare_gene_lists_for_enrichr <- function(
    all_levels_clustering,
    genes
) {

  formatted_gene_lists <- list()
  
  for (i in seq_along(all_levels_clustering)) {
    
    if (is.logical(all_levels_clustering[[i]])) next
    
    level_name <- names(all_levels_clustering)[i]
    clustered_hits <- all_levels_clustering[[i]]$clustered_hits
    
    # Process each cluster
    clusters <- split(
      clustered_hits$feature,
      clustered_hits$cluster
    )
    
    level_gene_lists <- list()
    
    for (cluster_id in names(clusters)) {
      cluster_genes <- clusters[[cluster_id]]

      gene_list <- genes[cluster_genes]
      gene_list <- na.omit(gene_list)  # Remove NAs if any
      
      if (length(gene_list) > 0) {
        level_gene_lists[[paste0("Cluster ", cluster_id)]] <- 
          paste(gene_list, collapse = "\n")
      }
    }
    
    formatted_gene_lists[[level_name]] <- level_gene_lists
  }
  
  # Prepare the background genes list using preprocessed genes
  background_gene_list <- paste(
    na.omit(genes),
    collapse = "\n"
    )
  
  return(list(
    gene_lists = formatted_gene_lists,
    background = background_gene_list
  ))
}




#' Build Cluster Hits Report
#'
#' @description
#' Generates an HTML report for clustered hits, including plots and
#' spline parameter details, with a table of contents.
#'
#' @param header_section A character string containing the HTML header section.
#' @param plots A list of ggplot2 plot objects.
#' @param limma_result_2_and_3_plots List containing the list of lists with all
#' the plots for all the pairwise comparisons of the condition in terms of
#' average spline diff and interaction condition time, and another list of lists
#' where the respective names of each plot are stored.
#' @param plots_sizes A list of integers specifying the size of each plot.
#' @param level_headers_info A list of header information for each level.
#' @param spline_params A list of spline parameters.
#' @param adj_pthresholds Float vector with values for any level for adj.p.tresh
#' @param mode A character string specifying the mode
#'            ('isolated' or 'integrated').
#' @param report_info A named list containg the report info fields. Here used
#'                    for the email hotkey functionality.
#' @param output_file_path A character string specifying the path to save the
#'                         HTML report.
#'
#' @return No return value, called for side effects.
#'
#' @seealso
#' \code{\link{plot2base64}}, \code{\link{create_progress_bar}}
#'
build_cluster_hits_report <- function(
    header_section,
    plots,
    limma_result_2_and_3_plots,
    plots_sizes,
    level_headers_info,
    spline_params,
    adj_pthresholds,
    mode,
    report_info,
    output_file_path
    ) {

  html_content <- paste(header_section, "<!--TOC-->", sep = "\n")
  
  toc <- create_toc()
  
  styles <- define_html_styles()
  section_header_style <- styles$section_header_style
  toc_style <- styles$toc_style

  current_header_index <- 1
  j <- 0
  level_headers_info <- Filter(Negate(is.null), level_headers_info)

  
  pb <- create_progress_bar(plots)

  header_index <- 0
  level_index <- 0
  
  # Generate the sections and plots
  for (index in seq_along(plots)) {
    header_index <- header_index + 1

    if (current_header_index <= length(level_headers_info)) {
      header_info <- level_headers_info[[current_header_index]]
      nr_hits <- header_info$nr_hits
      adj_pvalue_threshold <- header_info$adj_pvalue_threshold

      # means this is the section of a new level
      # The very first level is also a new level
      if (names(plots)[index] == "new_level") {
        
        level_index <- level_index + 1
        
        time_effect_section_header <- paste(
          "Time Effect of Condition:",
          header_info$header_name
        )
        
        section_header <- sprintf(
          "<h2 style='%s' id='section%d'>%s</h2>",
          section_header_style,
          header_index,
          time_effect_section_header
          )

        html_content <- paste(
          html_content,
          section_header,
          sep = "\n"
          )

        if (mode == "integrated") {
          j <- 1
        } else {      # mode == "isolated" or mode == NA
          j <- j + 1
        }

        spline_params_info <-
          get_spline_params_info(
            spline_params = spline_params,
            j = j
            )

        html_content <- paste(
          html_content,
          spline_params_info,
          sep = "\n"
          )

        hits_info <- sprintf(
          paste0(
            "<p style='text-align: center; font-size: 30px;'>",
            "adj.p-value threshold: %.3f</p>",
            "<p style='text-align: center; font-size: 30px;'>",
            "Number of hits: %d</p>",
            "<hr>"
          ),
          adj_pvalue_threshold,
          nr_hits
        )

        html_content <- paste(
          html_content,
          hits_info,
          sep = "\n"
          )

        toc_entry <- sprintf(
          "<li style='%s'><a href='#section%d'>%s</a></li>",
          toc_style,
          header_index,
          time_effect_section_header
          )
        toc <- paste(
          toc,
          toc_entry,
          sep = "\n"
          )

        current_header_index <- current_header_index + 1

        pb$tick()
        next
      }
    }

    element_name <- names(plots)[index]

    header_levels <- c(
      "dendrogram",
      "cluster_mean_splines",
      "heatmap",
      "individual_spline_plots"
    )

    if (element_name %in% header_levels) {
      
      if (element_name == "dendrogram") {
        header_text <- "Overall Clustering"
      } else if (element_name == "cluster_mean_splines") {
        header_text <- "Min-max normalized individual and mean splines"
      } else if (element_name == "heatmap") {
        header_text <- "Z-Score of log2 Value Heatmap"
        
        heatmap_description <- paste(
          "<div style='text-align: center; font-size: 1.5em;'>",
          "Rows = features (labels on the right, cluster labels on the left),",
          "columns = timepoints; Blue = down, red = up, --> compared to the rest
          of the row;",
          "</div>"
        )
      } else {  # element_name == "individual_spline_plots"
        adjusted_p_val <- adj_pthresholds[level_index]
        header_text <- "Individual Significant Features (Hits) Splines"
        asterisks_definition <- paste(
          "<b><span style='font-size:20pt; margin-bottom: 0;'>
          Asterisks definition:</span></b>",
          paste("Adj. p-value <", adjusted_p_val, "--> *", sep = " "),
          paste("Adj. p-value <", adjusted_p_val / 5, "--> **", sep = " "),
          paste("Adj. p-value <", adjusted_p_val / 50, "--> ***", sep = " "),
          sep = "<br>"
        )
      }
      
      # Add the main title as a section title with an anchor 
      # before the first plot
      header <- paste0(
        "<h2 id='section",
        header_index,
        "' style='text-align: center; font-size: 3.5em;'>",
        header_text,
        "</h2>",
        if (exists("heatmap_description")) heatmap_description else ""
      )
      
      if (exists("heatmap_description")) rm(heatmap_description)
      
      # Add the asterisks definition if it exists
      if (exists("asterisks_definition")) {
        header <- paste0(
          header,
          "<div style='text-align: center;",
          "font-size: 1.5em;'>",
          asterisks_definition,
          "</div>")
        
        rm(asterisks_definition)  # Otherwise, the next level has it everywhere
      }
      
      html_content <- paste(
        html_content,
        header,
        sep = "\n"
      )
      
      toc_entry <- paste0(
        "<li style='margin-left: 30px; font-size: 30px;'>",
        "<a href='#section",
        header_index,
        "'>",
        header_text, 
        "</a></li>"
      )
      
      toc <- paste(toc, toc_entry, sep = "\n")
    }
    
    header_index <- header_index + 1
    
    result <- process_plots(
      plots_element = plots[[index]],
      element_name = names(plots)[index],
      plots_size = plots_sizes[[index]],
      html_content = html_content,
      toc = toc,
      header_index = header_index
      )
    
    html_content <- result$html_content
    toc <- result$toc
    
    pb$tick()
  }
  
  # Add sections for limma_result_2_and_3_plots
  if (!is.null(limma_result_2_and_3_plots)) {
    adj_pthresh_avrg_diff_conditions <- 0.05
    adj_pthresh_interaction_condition_time <- 0.05
    # Create a new main header for the limma result plots
    header_index <- header_index + 1
    
    # Add the main header and anchor it
    limma_main_header <- sprintf(
      "<h2 style='%s' id='section%d'>%s</h2>",
      section_header_style,
      header_index,
      "Avrg diff conditions & interaction condition time"
    )
    
    html_content <- paste(
      html_content,
      limma_main_header,
      sep = "\n"
    )
    
    # Define the asterisks definition for both adjusted p-values, 
    # centered, with larger p-value text
    asterisks_definition_avrg_diff <- paste(
      "<div style='text-align:center; margin-bottom: 20px;'>",
      "<b><span style='font-size:24pt;
      '>Asterisks definition (Average Diff Conditions):</span></b><br>",
      paste(
        "<span style='font-size:18pt;'>Adj. p-value <",
        adj_pthresh_avrg_diff_conditions,
        "--> *</span>",
        sep = " "
        ),
      "<br>",
      paste(
        "<span style='font-size:18pt;'>Adj. p-value <",
        adj_pthresh_avrg_diff_conditions / 5,
        "--> **</span>",
        sep = " "
        ),
      "<br>",
      paste(
        "<span style='font-size:18pt;'>Adj. p-value <",
        adj_pthresh_avrg_diff_conditions / 50,
        "--> ***</span>",
        sep = " "
        ),
      "</div>",
      sep = "\n"
    )
    
    asterisks_definition_interaction <- paste(
      "<div style='text-align:center; margin-bottom: 40px;'>",  
      "<b><span style='font-size:24pt;
      '>Asterisks definition (Interaction):</span></b><br>",
      paste(
        "<span style='font-size:18pt;'>Adj. p-value <",
        adj_pthresh_interaction_condition_time,
        "--> *</span>",
        sep = " "
        ),
      "<br>",
      paste(
        "<span style='font-size:18pt;'>Adj. p-value <",
        adj_pthresh_interaction_condition_time / 5,
        "--> **</span>",
        sep = " "
        ),
      "<br>",
      paste(
        "<span style='font-size:18pt;'>Adj. p-value <",
        adj_pthresh_interaction_condition_time / 50,
        "--> ***</span>",
        sep = " "
        ),
      "</div>",
      sep = "\n"
    )
    
    # Add the asterisks definitions to the HTML content
    html_content <- paste(
      html_content,
      asterisks_definition_avrg_diff,
      asterisks_definition_interaction,
      sep = "\n"
    )
    
    # Add an entry in the table of contents for this new section
    toc_entry <- sprintf(
      "<li style='%s'><a href='#section%d'>%s</a></li>",
      toc_style,
      header_index,
      "Avrg diff conditions & interaction condition time"
    )
    toc <- paste(
      toc,
      toc_entry,
      sep = "\n"
    )
    
    # Loop over each element in limma_result_2_and_3_plots
    for (comparison_name in names(limma_result_2_and_3_plots)) {
      
      # Create a subheader for each comparison
      header_index <- header_index + 1
      subheader <- sprintf(
        "<h3 style='font-size: 3.5em; color: #001F3F; text-align: center;'
        id='section%d'>%s</h3>",
        header_index,
        comparison_name
      )
      
      html_content <- paste(
        html_content,
        subheader,
        sep = "\n"
      )
      
      # Add an entry in the TOC for this subheader
      toc_entry <- paste0(
        "<li style='margin-left: 30px; font-size: 30px;'>",
        "<a href='#section",
        header_index,  
        "'>",
        comparison_name, 
        "</a></li>"
      )
      
      toc <- paste(
        toc,
        toc_entry,
        sep = "\n"
      )
      
      # Extract plot_list and feature_names_list for the current comparison
      comparison <- limma_result_2_and_3_plots[[comparison_name]]
      comparison_plots <- comparison$plots
      comparison_feature_names <- comparison$feature_names
      
      # Iterate through each plot and its corresponding feature name
      for (i in seq_along(comparison_plots)) {
        # Add the feature name as a copyable text above the plot
        feature_name_div <- sprintf(
          '<div style="text-align: center; 
          font-size: 36px; margin-bottom: 10px;">%s</div>',
          comparison_feature_names[[i]]
        )
        
        html_content <- paste(
          html_content,
          feature_name_div,  # Add the feature name above the plot
          sep = "\n"
        )
        
        # Now add the plot itself
        result <- process_plots(
          plots_element = comparison_plots[[i]],
          plots_size = 1.5,  
          html_content = html_content,
          toc = toc,
          header_index = header_index,
          element_name = ""  
        )
        
        html_content <- result$html_content
        toc <- result$toc
      }
    }
  }

  generate_and_write_html(
    toc = toc,
    html_content = html_content,
    report_info = report_info,
    output_file_path = output_file_path
  )
}


# Level 3 internal functions ---------------------------------------------------


#' Calculate Curve Values Based on Top Table Filter
#'
#' @description This function filters entries from a given top table based on
#' an adjusted p-value threshold,
#' performs spline interpolation using specified degrees of freedom, and
#' calculates curve values
#' for the selected entries at predefined time points. The function is
#' internal and not exported.
#'
#' @param top_table A data frame containing data with a column for adjusted
#' p-values and
#'                  expression averages which indicate the number of degrees
#'                  of freedom.
#' @param level The specific level of the condition to filter on in the
#' metadata.
#' @param meta Metadata containing time points and conditions.
#' @param condition The name of the condition column in the metadata to filter
#' on.
#' @param spline_params A list of spline parameters for the analysis.
#' @param mode A character string specifying the mode
#' ('isolated' or 'integrated').
#'
#' @return A list containing two elements: `curve_values`, a data frame of
#' curve values for each filtered entry, and `smooth_timepoints`, the time
#' points at which curves were evaluated.
#'
#' @importFrom dplyr select all_of
#' @importFrom splines ns
#'
get_curve_values <- function(
    top_table,
    level,
    meta,
    condition,
    spline_params,
    mode
    ) {

  subset_meta <- meta[meta[[condition]] == level, ]

  if (mode == "isolated") {
    level_index <- match(level, unique(meta[[condition]]))
  }
  else if (mode == "integrated") {
    level_index <- 1   # Different spline params not supported for this mode
  }

  smooth_timepoints <- seq(
    subset_meta$Time[1],
    subset_meta$Time[length(subset_meta$Time)],
    length.out = 1000   # To ensure smoothness of the curve.
    )

  args <- list(x = smooth_timepoints, intercept = FALSE)

  if (!is.null(spline_params$dof)) {
    args$df <- spline_params$dof[level_index]
  } else {
    args$knots <- spline_params$knots[[level_index]]
  }

  if (!is.null(spline_params$bknots)) {
    args$Boundary.knots <- spline_params$bknots[[level_index]]
  }


  if (spline_params$spline_type[level_index] == "b") {
    args$degree <- spline_params$degree[level_index]
    X <- do.call(splines::bs, args)
  } else {                                          # natural cubic splines
    X <- do.call(splines::ns, args)
  }

  DoF <- which(names(top_table) == "AveExpr") - 1

  # columns_to_select <- 1:DoF

  splineCoeffs <- top_table |>
    dplyr::select(all_of(1:DoF)) |>
    as.matrix()

  curve_values <- matrix(
    nrow = nrow(splineCoeffs),
    ncol = length(smooth_timepoints)
    )

  for(i in 1:nrow(splineCoeffs)) {
    current_coeffs <- matrix(
      splineCoeffs[i, ],
      ncol = ncol(splineCoeffs),
      byrow = TRUE
      )

    curve_values[i, ] <- current_coeffs %*% t(X)
  }

  curve_values <- as.data.frame(curve_values)
  rownames(curve_values) <- rownames(splineCoeffs)
  
  list(
    curve_values = curve_values,
    smooth_timepoints = smooth_timepoints,
    X = X
    )
}


#' Normalize Curve Values
#'
#' @description This function normalizes each row in a data frame or matrix
#' of curve values.
#' Normalization is performed so that each row's values range from 0
#' (corresponding to the
#' minimum value of the row) to 1
#' (corresponding to the maximum value of the row).
#'
#' @param curve_values A data frame or matrix of curve values where each row
#' represents
#'        a curve and each column a time point.
#' @return A data frame or matrix with the same dimensions as the input, where
#'  each row
#'         has been normalized.
#'
normalize_curves <- function(curve_values) {

  normalized_curves <- apply(curve_values, 1, function(row) {
    (row - min(row)) / (max(row) - min(row))
  })

  normalized_curves <- t(normalized_curves)
  curve_values[,] <- normalized_curves
  curve_values
}


#' Hierarchical Clustering of Curve Values
#'
#' @description Performs hierarchical clustering on given curve values.
#' The function adjusts the provided top_table with cluster
#' assignments.
#'
#' @param curve_values A matrix or data frame of curve values to cluster.
#' @param k The number of clusters to use.
#' @param smooth_timepoints Numeric vector of time points corresponding to
#'                          columns in curve_values.
#' @param top_table Data frame to be updated with cluster assignments.
#' @return A list containing clustering results and the modified top_table.
#'
#' @importFrom stats dist hclust cutree
#'
hierarchical_clustering <- function(
    curve_values,
    k,
    smooth_timepoints,
    top_table
    ) {

  distance_matrix <- stats::dist(curve_values, method = "euclidean")
  hc <- stats::hclust(distance_matrix, method = "complete")

  cluster_assignments <- stats::cutree(hc, k = k)

  clustered_hits <- data.frame(cluster = cluster_assignments)

  clustered_hits$feature <- top_table$feature_nr
  clustered_hits <- clustered_hits[, c("feature", "cluster")]

  colnames(curve_values) <- smooth_timepoints
  curve_values$cluster <- cluster_assignments

  top_table$cluster <- NA
  top_table$cluster[1:nrow(clustered_hits)] <-
    as.integer(clustered_hits$cluster)

  group_clustering <- list(
    clustered_hits = clustered_hits,
    hc = hc,
    curve_values = curve_values,
    top_table = top_table,
    clusters = k
    )
}


#' Get Spline Parameters Info
#'
#' @description
#' This function retrieves the spline parameters information for a given index.
#' It ensures the spline parameters are valid and constructs an HTML string
#' describing the spline parameters.
#'
#' @param spline_params A list containing the spline parameters. The list should
#'                      include elements: `spline_type`, `degree`, `dof`,
#'                      `knots`, and `bknots`.
#' @param j An integer specifying the index of the spline parameters to
#' retrieve.
#'
#' @details
#' The function checks if the spline parameters are not `NULL` and have a length
#' greater than or equal to the specified index `j`. If a parameter is
#' invalid or
#' missing, it sets the parameter to `NA`. It then constructs an HTML string
#' describing the spline parameters, including spline type, degree, degrees of
#' freedom (DoF), knots, and boundary knots.
#'
#' @return A character string containing HTML-formatted information about the
#'         spline parameters at the specified index.
#'
get_spline_params_info <- function(
    spline_params,
    j
    ) {

  if (!is.null(spline_params$spline_type) &&
      length(spline_params$spline_type) >= j) {
    spline_params$spline_type[j] <- spline_params$spline_type[j]
  } else {
    spline_params$spline_type[j] <- NA
  }

  if (!is.null(spline_params$degree) &&
      length(spline_params$degree) >= j) {
    spline_params$degree[j] <- spline_params$degree[j]
  } else {
    spline_params$degree[j] <- NA
  }

  if (!is.null(spline_params$dof) &&
      length(spline_params$dof) >= j) {
    spline_params$dof[j] <- spline_params$dof[j]
  } else {
    spline_params$dof[j] <- NA
  }

  if (!is.null(spline_params$knots) &&
      length(spline_params$knots) >= j) {
    spline_params$knots[j] <- spline_params$knots[j]
  } else {
    spline_params$knots[j] <- NA
  }

  if (!is.null(spline_params$bknots) &&
      length(spline_params$bknots) >= j) {
    spline_params$bknots[j] <- spline_params$bknots[j]
  } else {
    spline_params$bknots[j] <- NA
  }

  if (spline_params$spline_type[j] == "b") {
    spline_params_info <- sprintf("
    <p style='text-align: center; font-size: 30px;'>
        <span style='color: blue;'>Spline-type:</span> B-spline<br>
        <span style='color: blue;'>Degree:</span> %s<br>
        <span style='color: blue;'>DoF:</span> %s<br>
        <span style='color: blue;'>Knots:</span> %s<br>
        <span style='color: blue;'>Boundary-knots:</span> %s
    </p>",
    spline_params$degree[j], spline_params$dof[j],
    spline_params$knots[j], spline_params$bknots[j])
  } else {    # spline_type == "n"
    spline_params_info <- sprintf("
    <p style='text-align: center; font-size: 30px;'>
        <span style='color: blue;'>Spline-type:</span> Natural cubic spline<br>
        <span style='color: blue;'>DoF:</span> %s<br>
        <span style='color: blue;'>Knots:</span> %s<br>
        <span style='color: blue;'>Boundary-knots:</span> %s
    </p>",
    spline_params$dof[j], spline_params$knots[j],
    spline_params$bknots[j])
  }
  return(spline_params_info)
}


#' Truncate Row Names
#'
#' @description
#' This function truncates row names that exceed a specified maximum length.
#' If the row name length exceeds the maximum length, it appends " ..."
#' to indicate truncation.
#'
#' @param names A character vector of row names.
#' @param max_length An integer specifying the maximum length of the row names.
#' Default is 40.
#'
#' @return A character vector of truncated row names.
#'
truncate_row_names <- function(
    names,
    max_length = 40
    ) {
  sapply(names, function(x) {
    if (nchar(x) > max_length) {
      return(paste0(substr(x, 1, max_length - 3), " ..."))
    } else {
      return(x)
    }
  })
}


#' Plot Single and Mean Splines
#'
#' @description
#' Generates a plot showing individual time series shapes and their consensus
#' (mean) shape.
#'
#' @param time_series_data A dataframe or matrix with time series data.
#' @param title A character string specifying the title of the plot.
#' @param plot_info List containing the elements y_axis_label (string), 
#'                  time_unit (string), treatment_labels (character vector),
#'                  treatment_timepoints (integer vector). All can also be NA. 
#'                  This list is used to add this info to the spline plots. 
#'                  time_unit is used to label the x-axis, and treatment_labels
#'                  and -timepoints are used to create vertical dashed lines,
#'                  indicating the positions of the treatments (such as 
#'                  feeding, temperature shift, etc.).
#'
#' @return A ggplot object representing the single and consensus shapes.
#'
#' @seealso
#' \code{\link{ggplot2}}
#'
#' @importFrom dplyr arrange mutate
#' @importFrom tibble rownames_to_column
#' @importFrom tidyr pivot_longer
#' @importFrom ggplot2 ggplot geom_line scale_colour_manual theme_minimal
#'                     ggtitle aes labs element_rect
#' @importFrom rlang sym .data
#' @importFrom scales hue_pal
#'
plot_single_and_mean_splines <- function(
    time_series_data,
    title,
    plot_info
) {
  
  time_col <- rlang::sym("time")
  feature_col <- rlang::sym("feature")
  
  # Convert data to long format
  df_long <- as.data.frame(t(time_series_data)) |>
    tibble::rownames_to_column(var = "time") |>
    tidyr::pivot_longer(
      cols = -!!time_col,
      names_to = "feature",
      values_to = "intensity"
    ) |>
    dplyr::arrange(!!feature_col) |>
    dplyr::mutate(time = as.numeric(.data$time))
  
  # Compute consensus (mean of each column)
  consensus <- colMeans(time_series_data, na.rm = TRUE)
  
  consensus_df <- data.frame(
    time = as.numeric(colnames(time_series_data)),
    consensus = consensus
  )
  
  time_unit_label = paste0("[", plot_info$time_unit, "]")
  
  color_values <- c(
    "Mean" = "darkblue",
    "Spline" = "#6495ED"
  )
  
  p <- ggplot2::ggplot() +
    ggplot2::geom_line(
      data = df_long, 
      ggplot2::aes(
        x = !!rlang::sym("time"),
        y = !!rlang::sym("intensity"),
        group = !!rlang::sym("feature"),
        colour = "Spline"
      ), 
      alpha = 0.3, linewidth = 0.5) +
    ggplot2::geom_line(
      data = consensus_df,
      ggplot2::aes(
        x = !!rlang::sym("time"),
        y = consensus,
        colour = "Mean"
      ),
      linewidth = 1.5)
  
  # Conditionally add vertical dashed lines if treatment_labels is not NA
  if (!all(is.na(plot_info$treatment_labels))) {
    treatment_labels <- plot_info$treatment_labels
    # Create a data frame for treatment lines
    treatment_df <- data.frame(
      Time = plot_info$treatment_timepoints,
      Label = treatment_labels
    )
    
    p <- p +
      ggplot2::geom_vline(
        data = treatment_df, 
        ggplot2::aes(
          xintercept = .data$Time,
          color = .data$Label
        ), 
        linetype = "dashed", 
        size = 0.5
      ) +
      ggplot2::geom_text(
        data = treatment_df,
        ggplot2::aes(
          x = .data$Time - max(.data$Time) * 0.005,   # not touching line
          y = 1,
          label = .data$Time,
          color = .data$Label
        ),  
        angle = 90,
        vjust = 0,
        hjust = 1,  
        size = 3,  
        show.legend = FALSE  
      )
    
    # Generate colors for treatments
    distinct_colors <- scales::hue_pal()(length(treatment_labels))
    names(distinct_colors) <- treatment_labels
    color_values <- c(color_values, distinct_colors)
  }
  
  p <- p +
    ggplot2::scale_colour_manual(
      name = "",
      values = color_values,
      guide = ggplot2::guide_legend(
        override.aes = list(
          size = c(
            1.5,
            0.5,
            rep(
              0.5,
              length(na.omit(plot_info$treatment_labels))
              )
            )  
        )
      )
    ) +
    ggplot2::coord_cartesian(clip = "off") +
    ggplot2::theme_minimal() +
    ggplot2::labs(
      title = title,
      x = paste("Time", time_unit_label),
      y = paste("min-max norm.", plot_info$y_axis_label)
    ) +
    ggplot2::theme(
      plot.margin = grid::unit(c(1, 1, 1.5, 1), "lines"),  
      legend.position = "right",
      legend.box = "vertical",
      legend.title = ggplot2::element_text(size = 8), 
      legend.background = ggplot2::element_blank(),
      axis.title.y = ggplot2::element_text(size = 6),
      plot.title = ggplot2::element_text(hjust = 0.5),
      legend.key.size = grid::unit(0.6, "cm"),  
      legend.key.height = grid::unit(0.3, "cm")  
    )
  
  return(p)
}

