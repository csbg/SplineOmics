#' cluster_hits.R contains the exported package function cluster_hits and all
#' the functions that make up the functionality of cluster_hits. cluster_hits
#' clusters the hits of a time series omics datasets (the features that were 
#' significantly changed over the time course) with hierarchical clustering of
#' the spline shape.


# Exported function: cluster_hits() --------------------------------------------


#' Cluster Hits from Top Tables
#'
#' Performs clustering on hits from top tables generated by differential 
#' expression analysis.
#' This function filters hits based on adjusted p-value thresholds, extracts 
#' spline coefficients for 
#' significant features, normalizes these coefficients, and applies hierarchical 
#' clustering. The results,
#' including clustering assignments and normalized spline curves, are saved in a 
#' specified directory and
#' compiled into an HTML report.
#'
#' @param top_tables A list of data frames, each representing a top table from 
#' differential expression
#'        analysis, containing at least 'adj.P.Val' and expression data columns.
#' @param data The original expression dataset used for differential expression 
#' analysis.
#' @param meta Metadata dataframe corresponding to the `data`, must include a 
#' 'Time' column and any columns
#'        specified by `conditions`.
#' @param conditions Character vector specifying the column names in `meta` used 
#' to define groups for
#'        analysis.
#' @param adj_pthresh Numeric vector of p-value thresholds for filtering hits in 
#' each top table.
#' @param clusters Integer vector specifying the number of clusters to cut the 
#' dendrogram into, for each
#'        group factor.
#' @param report_dir Character string specifying the directory path where the 
#' HTML report and any
#'        other output files should be saved.
#'
#' @return A list where each element corresponds to a group factor and contains 
#' the clustering results,
#'         including `clustered_hits` data frame, hierarchical clustering object 
#'         `hc`, `curve_values`
#'         data frame with normalized spline curves, and `top_table` with 
#'         cluster assignments.
#'
#' @examples
#' \dontrun{
#'   cluster_results <- cluster_hits(top_tables, data, meta, c("GroupFactor"), 
#'                                   c(0.05),
#'                                   c(3), "path/to/report/dir")
#' }
#'
#' @seealso \code{\link[limma]{topTable}}, \code{\link[stats]{hclust}}
#' 
#' @export
#' 
cluster_hits <- function(top_tables,  # limma topTable (from run_limma_splines)
                         data, 
                         meta, 
                         condition,   # meta factor column
                         report_info,   # Gets printed on top of the report
                         mode = "integrated",  # dependent on limma design
                         spline_params = list(spline_type = c("n"),
                                              dof = c(2L)),
                         adj_pthresholds = c(0.05),
                         clusters = c("auto"),
                         meta_batch_column = NA,   # to remove batch effect
                         time_unit = "m",    # For the plot labels
                         report_dir = here::here()) {

  control_inputs_cluster_hits(top_tables = top_tables, 
                              data = data, 
                              meta = meta, 
                              condition = condition, 
                              spline_params = spline_params,
                              mode = mode,
                              adj_pthresholds = adj_pthresholds, 
                              clusters = clusters,
                              report_info = report_info,
                              meta_batch_column = meta_batch_column,
                              time_unit = time_unit,
                              report_dir = report_dir)
  
  # To set the default p-value threshold for ALL levels.
  if (is.numeric(adj_pthresholds) && 
      length(adj_pthresholds) == 1 && adj_pthresholds[1] == 0.05) {
    levels <- unique(meta[[condition]])
    adj_pthresholds <- rep(adj_pthresholds[1], length(levels))
  }
  
  all_levels_clustering <- perform_clustering(top_tables = top_tables,
                                              adj_pthresholds = adj_pthresholds,
                                              clusters = clusters,
                                              meta = meta,
                                              condition = condition,
                                              spline_params = spline_params,
                                              mode = mode)
  
  make_clustering_report(all_levels_clustering = all_levels_clustering, 
                         condition = condition, 
                         data = data, 
                         meta = meta, 
                         spline_params = spline_params,
                         adj_pthresholds = adj_pthresholds, 
                         report_dir = report_dir,
                         mode = mode,
                         feature_names = feature_names,
                         report_info = report_info,
                         meta_batch_column = meta_batch_column,
                         time_unit = time_unit)
  
  return(all_levels_clustering)
}



# Level 1 internal functions ---------------------------------------------------


#' Control Inputs for Cluster Hits
#'
#' @description
#' Validates the inputs for clustering hits, ensuring all required structures 
#' and parameters are correctly formatted.
#'
#' @param top_tables A list of top tables from limma analysis.
#' @param data A matrix of data values.
#' @param meta A dataframe containing metadata.
#' @param mode A character string specifying the mode ('isolated' or 'integrated').
#' @param spline_params A list of spline parameters for the analysis.
#' @param condition A character string specifying the condition.
#' @param adj_pthresholds A numeric vector of p-values.
#' @param clusters A list specifying clusters or "auto" for automatic estimation.
#' @param report_info An object containing report information.
#' @param meta_batch_column A character string specifying the meta batch column.
#' @param time_unit A character string specifying the time unit ('s', 'm', 'h', 'd').
#' @param report_dir A character string specifying the report directory.
#'
#' @return No return value, called for side effects.
#'
#' @examples
#' top_tables <- list(data.frame(feature_index = 1:10, adj.P.Val = runif(10)))
#' data <- matrix(runif(100), nrow = 10)
#' meta <- data.frame(Time = seq(1, 10), batch = rep(c("A", "B"), each = 5))
#' mode <- "isolated"
#' spline_params <- list(spline_type = c("n"), dof = list(3))
#' condition <- "example_condition"
#' adj_pthresholds <- runif(10)
#' clusters <- list("auto")
#' report_info <- "example_info"
#' meta_batch_column <- "batch"
#' time_unit <- "m"
#' report_dir <- "example_dir"
#' control_inputs_cluster_hits(top_tables, data, meta, mode, spline_params, 
#'                             condition, adj_pthresholds, clusters, report_info, 
#'                             meta_batch_column, time_unit, report_dir)
#'
#' @seealso
#' \code{\link{check_top_tables}}, \code{\link{check_meta}}, 
#' \code{\link{check_mode}}, \code{\link{check_spline_params}}, 
#' \code{\link{validate_report_info}}
#' 
control_inputs_cluster_hits <- function(top_tables, 
                                        data, 
                                        meta, 
                                        mode,
                                        spline_params,
                                        condition, 
                                        adj_pthresholds, 
                                        clusters, 
                                        report_info,
                                        meta_batch_column,
                                        time_unit,
                                        report_dir) {
  
  check_top_tables(top_tables)

  if (!is.matrix(data)) {
    stop("data must be a matrix")
  }
  
  check_meta(meta, meta_batch_column)
  
  check_mode(mode)
  
  check_spline_params(spline_params, mode)
  
  if (!(is.character(condition)) || length(condition) != 1) {
    stop("condition must be a character vector with length 1")
  }
  
  check_adj_pthresholds(adj_pthresholds)
  
  if (is.character(clusters) && length(clusters) == 1 && clusters[1] == "auto") 
    {
    print(paste0("No cluster amounts were specified as arguments. Default ", 
                 "argument is automatic cluster estimation."))
    
  } else if (!is.list(clusters) || 
      !all(sapply(clusters, function(x) is.character(x) || is.numeric(x)))) {
    stop("clusters must be a list containing only character or numeric types.")
  } 
  
  check_report_info(report_info)
  
  check_time_unit(time_unit)
  
  check_and_create_report_dir(report_dir)
}


#' Perform Clustering
#'
#' @description
#' Performs clustering on top tables using specified p-values and clusters 
#' for each level within a condition.
#'
#' @param top_tables A list of top tables from limma analysis.
#' @param adj_pthresholds A numeric vector of p-values.
#' @param clusters A list specifying clusters or "auto" for automatic estimation.
#' @param meta A dataframe containing metadata.
#' @param condition A character string specifying the condition.
#' @param spline_params A list of spline parameters for the analysis.
#' @param mode A character string specifying the mode ('isolated' or 'integrated').
#'
#' @return A list of clustering results for each level within the condition.
#'
#' @examples
#' top_tables <- list(data.frame(feature_index = 1:10, adj.P.Val = runif(10)))
#' adj_pthresholds <- runif(10)
#' clusters <- list("auto")
#' meta <- data.frame(Time = seq(1, 10), condition = rep(c("A", "B"), each = 5))
#' condition <- "condition"
#' spline_params <- list(spline_type = c("n"), dof = list(3))
#' mode <- "isolated"
#' perform_clustering(top_tables, adj_pthresholds, clusters, meta, condition, 
#'                    spline_params, mode)
#'
#' @seealso
#' \code{\link{process_level_cluster}}
#' 
perform_clustering <- function(top_tables,
                               adj_pthresholds,
                               clusters,
                               meta,
                               condition,
                               spline_params,
                               mode) {
  
  levels <- unique(meta[[condition]])
  
  if (is.character(clusters) && length(clusters) == 1 && clusters[1] == "auto") 
  {
    clusters <- rep(clusters[1], length(levels))
    
  }
  
  all_levels_clustering <- mapply(process_level_cluster, 
                                  top_tables, 
                                  adj_pthresholds, 
                                  clusters, 
                                  levels, 
                                  MoreArgs = list(meta = meta, 
                                                  condition = condition,
                                                  spline_params = spline_params,
                                                  mode = mode),
                                  SIMPLIFY = FALSE)  # Return a list
}


#' Make Clustering Report
#'
#' @description
#' Generates a detailed clustering report including heatmaps, dendrograms, 
#' curve plots, and consensus shapes for each level within a condition.
#'
#' @param all_levels_clustering A list containing clustering results for each 
#' level within a condition.
#' @param condition A character string specifying the condition.
#' @param data A matrix of data values.
#' @param meta A dataframe containing metadata.
#' @param spline_params A list of spline parameters for the analysis.
#' @param adj_pthresholds A numeric vector of p-values.
#' @param report_dir A character string specifying the report directory.
#' @param mode A character string specifying the mode ('isolated' or 'integrated').
#' @param feature_names A character vector of feature names.
#' @param report_info An object containing report information.
#' @param meta_batch_column A character string specifying the meta batch column.
#' @param time_unit A character string specifying the time unit ('s', 'm', 'h', 'd').
#'
#' @return No return value, called for side effects.
#'
#' @examples
#' all_levels_clustering <- list(
#'   list(clusters = 3, curve_values = data.frame(), hc = list(), top_table = data.frame())
#' )
#' condition <- "condition"
#' data <- matrix(runif(100), nrow = 10)
#' meta <- data.frame(Time = seq(1, 10), condition = rep(c("A", "B"), each = 5))
#' spline_params <- list(spline_type = c("n"), dof = list(3))
#' adj_pthresholds <- runif(10)
#' report_dir <- "example_dir"
#' mode <- "isolated"
#' feature_names <- paste0("feature", 1:10)
#' report_info <- "example_info"
#' meta_batch_column <- "batch"
#' time_unit <- "m"
#' make_clustering_report(all_levels_clustering, condition, data, meta, 
#'                        spline_params, adj_pthresholds, report_dir, mode, 
#'                        feature_names, report_info, meta_batch_column, time_unit)
#'
#' @seealso
#' \code{\link{removeBatchEffect}}, \code{\link{plot_heatmap}}, 
#' \code{\link{plot_dendrogram}}, \code{\link{plot_all_shapes}}, 
#' \code{\link{plot_consensus_shapes}}, \code{\link{plot_splines}}, 
#' \code{\link{generate_report_html}}
#' 
#' @importFrom limma removeBatchEffect
#' @importFrom dplyr filter
#' 
make_clustering_report <- function(all_levels_clustering, 
                                   condition, 
                                   data, 
                                   meta, 
                                   spline_params,
                                   adj_pthresholds, 
                                   report_dir,
                                   mode,
                                   feature_names,
                                   report_info,
                                   meta_batch_column,
                                   time_unit = time_unit) {
  
  if (!is.na(meta_batch_column)) {
    data <- removeBatchEffect(x = data, batch = meta[[meta_batch_column]])
  }
    
  # To extract the stored value for the potential auto cluster decision.
  clusters <- c()
  for (i in seq_along(all_levels_clustering)) {
    clusters <- c(clusters, as.integer(all_levels_clustering[[i]]$clusters))
    all_levels_clustering[[i]]$clusters <- NULL
  }
  
  if (!dir.exists(report_dir)) {
    dir.create(report_dir)
  }
  
  if (time_unit == "s") {
    time_unit_label = "[sec]"
  } else if (time_unit == "m") {
    time_unit_label = "[min]"
  } else if (time_unit == "h") {    
    time_unit_label = "[hours]"
  } else {                        # time-unit == "d"
    time_unit_label = "[days]"
  }
  
  heatmaps <- plot_heatmap(data,
                           meta,
                           condition,
                           feature_names,
                           all_levels_clustering,
                           time_unit_label)
  
  # log2_intensity_shape <- plot_log2_intensity_shapes()
  
  level_headers_info <- list()
  plots <- list()
  plots_sizes <- list()
  
  for (i in seq_along(all_levels_clustering)) {
    level_clustering <- all_levels_clustering[[i]]
    
    
    levels <- unique(meta[[condition]])
    
    if (length(levels) >= i) {
      # ith unique value from the 'condition' column of 'meta'
      ith_unique_value <- levels[i]
      
      # Construct header name
      header_name <- sprintf("Level: %s", ith_unique_value)
      
      # Determine the number of plots after which the header should be placed
      header_placement <- if (i == 1) 0 else 4 + clusters[i-1]
      
      header_info <- list(header_name = header_name, 
                          header_placement = header_placement)
      
      level_headers_info[[i]] <- header_info
    }
    
    curve_values <- level_clustering$curve_values
    
    dendrogram <- plot_dendrogram(level_clustering$hc, clusters[i])
    
    p_curves <- plot_all_shapes(curve_values, time_unit_label)
    
    consensus_shapes <- plot_consensus_shapes(curve_values, time_unit_label)
    
    top_table <- level_clustering$top_table
    adj_pthreshold <- adj_pthresholds[i]
    levels <- as.character(unique(meta[[condition]]))
    meta_level <- meta %>% dplyr::filter(.data[[condition]] == levels[i])
    sample_names <- as.character(meta_level$Sample)
    data_level <- data[, colnames(data) %in% sample_names]
    
    composite_plots <- list()
    nrows <- list()
    
    for (nr_cluster in unique(na.omit(top_table$cluster))) {
      main_title <- paste("Cluster", nr_cluster, sep = " ")
      
      top_table_filt <- top_table %>%
        dplyr::filter(adj.P.Val < adj_pthreshold, .data$cluster == nr_cluster)
      
      X <- level_clustering$X
      plot_splines_result <- plot_splines(top_table_filt, 
                                          data_level, 
                                          meta_level,
                                          X,
                                          main_title,
                                          time_unit_label)
      
      composite_plots[[length(composite_plots) + 1]] <- 
        plot_splines_result$composite_plot 
      
      nrows[[length(nrows) + 1]] <- plot_splines_result$nrows 
    }
    
    plots <- c(plots, 
               list(dendrogram, p_curves), 
               list(consensus_shapes$plot), 
               heatmaps[[i]], 
               composite_plots)
    
    # For every plot in plots, this determines the size in the HTML
    plots_sizes <- c(plots_sizes, 
                     1.5, 
                     1.5, 
                     consensus_shapes$size, 
                     1.5,
                     unlist(nrows))
  }
  print("Generating report. This takes a few seconds.")
  generate_report_html(plots = plots, 
                       plots_sizes = plots_sizes,
                       level_headers_info = level_headers_info,
                       spline_params = spline_params,
                       report_info = report_info,
                       report_type = "cluster_hits",
                       mode = mode,
                       filename = "report_clustered_hits",
                       report_dir = report_dir)
}



# Level 2 internal functions ---------------------------------------------------


#' Check Top Tables
#'
#' @description
#' Validates that the top tables are a list of dataframes and checks each 
#' dataframe using the `check_dataframe` function.
#'
#' @param top_tables A list of top tables from limma analysis.
#'
#' @return No return value, called for side effects.
#'
#' @examples
#' top_tables <- list(data.frame(feature_index = 1:10, adj.P.Val = runif(10)))
#' check_top_tables(top_tables)
#'
#' @seealso
#' \code{\link{check_dataframe}}
#' 
check_top_tables <- function(top_tables) {
  
  if (!is.list(top_tables) || !all(sapply(top_tables, is.data.frame))) {
    stop("top_tables must be a list of dataframes")
  } else {
    for (top_table in top_tables) {
      check_dataframe(top_table)
    }
  }
}


#' Check Meta
#'
#' @description
#' Validates the metadata dataframe ensuring it contains the required 'Time' 
#' column and checks the presence of the specified batch column if provided.
#'
#' @param meta A dataframe containing metadata.
#' @param meta_batch_column A character string specifying the meta batch column.
#'
#' @return No return value, called for side effects.
#'
#' @examples
#' meta <- data.frame(Time = seq(1, 10), batch = rep(c("A", "B"), each = 5))
#' check_meta(meta, "batch")
#'
#' @seealso
#' \code{\link{removeBatchEffect}}
#' 
check_meta <- function(meta, 
                       meta_batch_column) {
  
  if (!is.data.frame(meta) || !"Time" %in% names(meta)) {
    stop("meta must be a dataframe containing the column Time")
  }
  
  if (!is.na(meta_batch_column) && !(meta_batch_column %in% names(meta))) {
    stop(paste0("Column ", meta_batch_column, " not found in meta nr ", i))
    
  } else if (!is.na(meta_batch_column)) {
    print(paste0("Column ", meta_batch_column, " of meta will be used to ",
                 "remove the batch effect for the plotting"))
  } else {
    print("Batch effect will not be removed for plotting!")
  }
}


#' Process Level Cluster
#'
#' @description
#' Processes clustering for a specific level within a condition using the 
#' provided top table and spline parameters.
#'
#' @param top_table A dataframe containing the top table results from limma.
#' @param adj_pthreshold A numeric value specifying the p-value threshold.
#' @param cluster_size The size of clusters to generate.
#' @param level The level within the condition to process.
#' @param meta A dataframe containing metadata.
#' @param condition A character string specifying the condition.
#' @param spline_params A list of spline parameters for the analysis.
#' @param mode A character string specifying the mode 
#'            ('isolated' or 'integrated').
#'
#' @return A list containing the clustering results, including curve values and
#'         the design matrix.
#'
#' @examples
#' top_table <- data.frame(feature_index = 1:10, adj.P.Val = runif(10))
#' adj_pthreshold <- 0.05
#' cluster_size <- 3
#' level <- "A"
#' meta <- data.frame(Time = seq(1, 10), condition = rep(c("A", "B"), each = 5))
#' condition <- "condition"
#' spline_params <- list(spline_type = c("n"), dof = list(3))
#' mode <- "isolated"
#' process_level_cluster(top_table, adj_pthreshold, cluster_size, level, meta, 
#'                       condition, spline_params, mode)
#'
#' @seealso
#' \code{\link{get_curve_values}}, \code{\link{normalize_curves}}, 
#' \code{\link{hierarchical_clustering}}
#' 
process_level_cluster <- function(top_table,
                                  adj_pthreshold, 
                                  cluster_size, 
                                  level, 
                                  meta, 
                                  condition,
                                  spline_params,
                                  mode) {
  
  curve_results <- get_curve_values(top_table = top_table,
                                    adj_pthreshold = adj_pthreshold, 
                                    level = level, 
                                    meta = meta, 
                                    condition = condition,
                                    spline_params = spline_params,
                                    mode = mode)
  
  normalized_curves <- normalize_curves(curve_results$curve_values)
  
  clustering_result <- 
    hierarchical_clustering(curve_values = normalized_curves, 
                            k = cluster_size, 
                            smooth_timepoints = curve_results$smooth_timepoints, 
                            top_table = top_table)
  
  clustering_result$X <- curve_results$X
  return(clustering_result)
}

 
#' Plot Heatmap
#'
#' @description
#' Generates heatmaps for each level within a condition, showing z-scores of 
#' log2 intensity values, split by clusters.
#'
#' @param data A matrix of data values.
#' @param meta A dataframe containing metadata.
#' @param condition A character string specifying the condition.
#' @param feature_names A character vector of feature names.
#' @param all_levels_clustering A list containing clustering results for each 
#' level within the condition.
#' @param time_unit_label A character string specifying the time unit label.
#'
#' @return A list of ComplexHeatmap heatmap objects for each level.
#'
#' @examples
#' data <- matrix(runif(100), nrow = 10)
#' meta <- data.frame(Time = seq(1, 10), condition = rep(c("A", "B"), each = 5))
#' condition <- "condition"
#' feature_names <- paste0("feature", 1:10)
#' all_levels_clustering <- list(
#'   list(clustered_hits = data.frame(feature = 1:10, cluster = rep(1:2, 5)))
#' )
#' time_unit_label <- "[min]"
#' plot_heatmap(data, meta, condition, feature_names, all_levels_clustering, 
#'              time_unit_label)
#'
#' @seealso
#' \code{\link{ComplexHeatmap::Heatmap}}, \code{\link{dplyr::arrange}}
#' 
#' @importFrom dplyr arrange mutate group_by summarize
#' @importFrom tidyr pivot_longer separate
#' @importFrom ComplexHeatmap Heatmap draw ht_opt
#' @importFrom ggplot2 ggplot geom_line facet_wrap geom_vline ylab theme unit
#' @importFrom ggplot2 theme_bw scale_x_continuous
#' @importFrom grid gpar
#' 
plot_heatmap <- function(data,
                         meta,
                         condition,
                         feature_names,
                         all_levels_clustering,
                         time_unit_label) {

  BASE_TEXT_SIZE_PT <- 5
  
  ht_opt(
    simple_anno_size = unit(1.5, "mm"),
    COLUMN_ANNO_PADDING = unit(1, "pt"),
    DENDROGRAM_PADDING = unit(1, "pt"),
    HEATMAP_LEGEND_PADDING = unit(1, "mm"),
    ROW_ANNO_PADDING = unit(1, "pt"),
    TITLE_PADDING = unit(2, "mm"),
    heatmap_row_title_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    heatmap_row_names_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    heatmap_column_title_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    heatmap_column_names_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    legend_labels_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    legend_title_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    legend_border = FALSE
  )
  
  levels <- unique(meta[[condition]])
  heatmaps <- list()
  
  # Generate a heatmap for every level
  for (i in seq_along(all_levels_clustering)) {
    
    level_clustering <- all_levels_clustering[[i]]
    
    clustered_hits <- level_clustering$clustered_hits
    clusters <- clustered_hits %>% dplyr::arrange(cluster)
    
    level <- levels[[i]]
    level_indices <- which(meta[[condition]] == level)
    
    data_level <- data[, level_indices]
    data_level <- data_level[as.numeric(clusters$feature),]
    z_score <- t(scale(t(data_level)))
    
    meta_level <- meta[level_indices, ]
    
    ht <- 
      ComplexHeatmap::Heatmap(z_score,
                              column_split = meta_level$Time,
                              cluster_columns = FALSE,
                              row_split = clusters$cluster,
                              cluster_rows = FALSE,
                              heatmap_legend_param = list(title = "z-score of 
                                                                log2 intensity",
                                                          title_position = 
                                                            "lefttop-rot"),
                              row_gap = unit(2, "pt"),
                              column_gap = unit(2, "pt"),
                              # width = unit(2, "mm") * ncol(z_score) + 
                              #   5 * unit(2, "pt"),
                              # height = unit(2, "mm") * nrow(z_score) + 
                              #   5 * unit(2, "pt"),
                              show_row_names = TRUE,
                              show_column_names = TRUE)

    heatmaps[[length(heatmaps) + 1]] <- ht
  }
  heatmaps
}


# plot_log2_intensity_shapes <- function() {
#   # data_to_plot <- data.frame(first_protein_description = 
#   #                              rownames(data.matrix.batch.filt.sig), 
#   #                            data.matrix.batch.filt.sig) %>%
#   
#   
#   data_to_plot <- data %>%
#     dplyr::mutate(cluster_number = clusters$cluster) %>%
#     tidyr::pivot_longer(cols = colnames(data.matrix.batch.filt.sig),
#                         names_to = "sample_name",
#                         values_to = "log2_intensity") %>%
#     tidyr::separate(sample_name, 
#                     into = c("reactor", "time_point", "phase_of_fermentation"),
#                     sep = "_") %>%
#     dplyr::mutate(time_to_feed = rep(meta_exp_filt$time_to_feed,
#                                      length(clusters_exp$feature))) %>%
#     dplyr::group_by(first_protein_description) %>%
#     dplyr::mutate(log2_intensity = rescale(log2_intensity))
#   
#   
#   data_to_plot_mean_protein  <- data_to_plot %>%
#     dplyr::group_by(first_protein_description, time_to_feed) %>%
#     dplyr::mutate(mean_intensity_protein = mean(log2_intensity)) %>%
#     ungroup()
#   
#   data_to_plot_mean_tp <- data_to_plot %>%
#     dplyr::group_by(cluster_number, time_to_feed) %>%
#     dplyr::summarise(mean_intensity_tp = mean(log2_intensity)) 
#   
#   clusters_exp %>%
#     count(cluster)
#   
#   ggplot2::ggplot(data = data_to_plot_mean_protein) +
#     geom_line(aes(x = time_to_feed, y = mean_intensity_protein, 
#                   color = first_protein_description), alpha = 0.5) +
#     geom_line(data = data_to_plot_mean_tp,aes(x = time_to_feed, 
#                                               y = mean_intensity_tp), 
#               linewidth = 0.8) +
#     facet_wrap(~cluster_number, ncol = 2, 
#                labeller = labeller(cluster_number =  
#                                      c("1" = "Cluster 1: 32 proteins",
#                                        "2" = "Cluster 2: 48 proteins",
#                                        "3" = "Cluster 3: 68 proteins",
#                                        "4" = "Cluster 4: 29 proteins",
#                                        "5" = "Cluster 5: 17 proteins",
#                                        "6" = "Cluster 6: 13 proteins")))  +
#     geom_vline(xintercept = 0, linetype = 'dashed', color = 'red', 
#                linewidth = 0.5) +  
#     ylab("normalized log2 intensity") +
#     theme_bw() +
#     theme(legend.position = "none",
#           panel.grid.minor = element_blank()) +
#     scale_x_continuous(breaks = data_to_plot$time_to_feed)
#   
#   # 
#   # ht= ComplexHeatmap::draw(ht, heatmap_legend_side = "right")
#   # 
#   # print(ht)
# }


#' Plot Dendrogram
#'
#' @description
#' Generates a dendrogram plot for hierarchical clustering results, colored by clusters.
#'
#' @param hc A hierarchical clustering object.
#' @param k An integer specifying the number of clusters.
#'
#' @return A ggplot object representing the dendrogram.
#'
#' @examples
#' hc <- hclust(dist(matrix(runif(100), nrow = 10)))
#' k <- 3
#' plot_dendrogram(hc, k)
#'
#' @seealso
#' \code{\link{dendextend::color_branches}}, \code{\link{dendextend::as.ggdend}}, 
#' \code{\link{ggplot2}}
#' 
#' @importFrom stats as.dendrogram
#' @importFrom stats cutree
#' @importFrom RColorBrewer brewer.pal.info
#' @importFrom RColorBrewer brewer.pal
#' @importFrom dendextend color_branches
#' @importFrom dendextend as.ggdend
#' @importFrom ggplot2 ggplot
#' @importFrom ggplot2 labs
#' @importFrom ggplot2 theme_minimal
#' @importFrom ggplot2 theme
#' 
plot_dendrogram <- function(hc, 
                            k) {
  
  dend <- stats::as.dendrogram(hc)
  clusters <- stats::cutree(hc, k)

  palette_name <- "Set3"
  max_colors_in_palette <-
    RColorBrewer::brewer.pal.info[palette_name, "maxcolors"]
  colors <-
    RColorBrewer::brewer.pal(min(max_colors_in_palette, k), palette_name)
  if (k > max_colors_in_palette) {
    colors <- rep(colors, length.out = k)
  }

  dend_colored <- dendextend::color_branches(dend, k = k,
                                             labels_colors = colors)
  
  dend_colored <- dendextend::set(dend_colored, "labels", value = NULL)

  ggdend <- dendextend::as.ggdend(dend_colored)
  p_dend <- ggplot2::ggplot(ggdend) +
    labs(title = "Hierarchical Clustering Dendrogram (colors = clusters)",
         x = "", y = "") +
    theme_minimal() +
    theme(axis.text.x = element_blank(), axis.ticks.x = element_blank(),
          axis.text.y = element_blank(), axis.ticks.y = element_blank())
}


#' Plot All Shapes
#'
#' @description
#' Generates a plot of average curves for each cluster, showing min-max 
#' normalized intensities over time.
#'
#' @param curve_values A dataframe containing curve values and cluster 
#' assignments.
#' @param time_unit_label A character string specifying the time unit label.
#'
#' @return A ggplot object representing the average curves by cluster.
#'
#' @examples
#' curve_values <- data.frame(
#'   Time1 = runif(10), Time2 = runif(10), Time3 = runif(10), 
#'   cluster = rep(1:2, each = 5)
#' )
#' time_unit_label <- "[min]"
#' plot_all_shapes(curve_values, time_unit_label)
#'
#' @seealso
#' \code{\link{ggplot2}}
#' 
#' @importFrom ggplot2 ggplot geom_line ggtitle xlab ylab scale_color_brewer
#'             theme_minimal
#' 
plot_all_shapes <- function(curve_values,
                            time_unit_label) {
  
  time <- as.numeric(colnames(curve_values)[-length(colnames(curve_values))])
  
  clusters <- unique(curve_values$cluster)
  average_curves <- data.frame()
  
  # Loop through each unique cluster value to calculate the average curve
  for (current_cluster in clusters) {
    # Filter rows for the current cluster
    subset_hits <- curve_values[curve_values$cluster == current_cluster, ]
    last_timepoint <- (which(names(curve_values) == "cluster")) - 1
    average_curve <- colMeans(subset_hits[,1:last_timepoint])
    
    # Create a data frame for the average curve with an additional 'Cluster' 
    # column
    curve_df <- data.frame(Time = time, Value = average_curve, 
                           cluster = as.factor(current_cluster))
    
    # Bind the curve data frame to the cumulative data frame
    average_curves <- rbind(average_curves, curve_df)
  }
  
  average_curves$cluster <- 
    factor(average_curves$cluster, 
           levels = sort(unique(as.numeric(average_curves$cluster))))
  
  p_curves <- ggplot2::ggplot(average_curves, aes(x = Time, y = Value, color = 
                                                    factor(cluster))) +
    geom_line() + 
    ggtitle("Average Curves by Cluster") +
    xlab(paste0("Time ", time_unit_label)) + 
    ylab("min-max normalized intensities") +
    scale_color_brewer(palette = "Dark2", 
                       name = "Cluster") + 
    theme_minimal()
}

 
#' Plot Single and Consensus Splines
#'
#' @description
#' Generates a plot showing individual time series shapes and their consensus 
#' (mean) shape.
#'
#' @param time_series_data A dataframe or matrix with time series data.
#' @param title A character string specifying the title of the plot.
#' @param time_unit_label A character string specifying the time unit label.
#'
#' @return A ggplot object representing the single and consensus shapes.
#'
#' @examples
#' time_series_data <- matrix(runif(100), nrow = 10, 
#'                            dimnames = list(NULL, seq(1, 10)))
#' title <- "Single and Consensus Shapes"
#' time_unit_label <- "[min]"
#' plot_single_and_consensus_splines(time_series_data, title, time_unit_label)
#'
#' @seealso
#' \code{\link{ggplot2}}
#' 
#' @importFrom dplyr arrange mutate
#' @importFrom tibble rownames_to_column
#' @importFrom tidyr pivot_longer
#' @importFrom ggplot2 ggplot geom_line scale_colour_manual theme_minimal 
#' ggtitle xlab ylab
#' 
plot_single_and_consensus_splines <- function(time_series_data, 
                                              title,
                                              time_unit_label) {
  
  # Transform the dataframe to a long format for ggplot2
  df_long <- as.data.frame(t(time_series_data)) %>%
    tibble::rownames_to_column(var = "time") %>%
    tidyr::pivot_longer(cols = -time, names_to = "feature", 
                        values_to = "intensity") %>%
    dplyr::arrange(feature) %>%
    dplyr::mutate(time = as.numeric(time))
  
  # Compute consensus (mean of each column)
  consensus <- colMeans(time_series_data, na.rm = TRUE)
  consensus_df <- data.frame(time = as.numeric(colnames(time_series_data)), 
                             consensus = consensus)
  
  p <- ggplot2::ggplot() +
    geom_line(data = df_long, aes(x = time, y = intensity, group = feature,
                                  colour = "Single Shapes"),
              alpha = 0.3, linewidth = 0.5) +
    geom_line(data = consensus_df, aes(x = time, y = consensus,
                                       colour = "Consensus Shape"),
              linewidth = 1.5) +
    scale_colour_manual("", values = c("Consensus Shape" = "darkblue",
                                       "Single Shapes" = "#6495ED")) +
    theme_minimal() +
    labs(
      title = title,
      x = paste("Time ", time_unit_label),     
      y = "Intensity") +
    # ggtitle(title) +
    theme(legend.position = "none")
}


#' Plot Consensus Shapes
#'
#' @description
#' Generates composite plots of single and consensus shapes for each cluster 
#' of curve values.
#'
#' @param curve_values A dataframe containing curve values and cluster assignments.
#' @param time_unit_label A character string specifying the time unit label.
#'
#' @return A list containing the composite plot of consensus shapes and its size.
#'
#' @examples
#' curve_values <- data.frame(
#'   Time1 = runif(10), Time2 = runif(10), Time3 = runif(10), 
#'   cluster = rep(1:2, each = 5)
#' )
#' time_unit_label <- "[min]"
#' plot_consensus_shapes(curve_values, time_unit_label)
#'
#' @seealso
#' \code{\link{plot_single_and_consensus_splines}}, \code{\link{patchwork}}
#' 
plot_consensus_shapes <- function(curve_values, 
                                  time_unit_label) {
  
  clusters <- sort(unique(curve_values$cluster))
  time <- as.numeric(colnames(curve_values)[-length(colnames(curve_values))])
  
  plots <- list()
  for (current_cluster in clusters) {
    current_title <- paste("Cluster", current_cluster, sep = " ")
    subset_df <- subset(curve_values, cluster == current_cluster)
    subset_df$cluster <- NULL 
    
    plots[[length(plots) + 1]] <- 
      plot_single_and_consensus_splines(subset_df, 
                                        current_title,
                                        time_unit_label)
  }
  
  composite_consensus_shapes_plot <-
    patchwork::wrap_plots(plots, ncol = 2) +
    patchwork::plot_annotation(
      title = "min-max normalized single and consensus shapes",
      theme = ggplot2::theme(plot.title = element_text(hjust = 0.5, size = 14))
    )

  list(plot = composite_consensus_shapes_plot, 
       size = length(plots)/2)
}


#' Plot Splines for Features Based on Top Table Information
#'
#' @description This function generates plots for each feature listed in the
#' top table using spline 
#' interpolation for fitted values. It creates individual plots for each feature 
#' and combines 
#' them into a single composite plot. The function is internal and not exported.
#'
#' @param top_table A dataframe containing the indices and names of features, 
#' along with their 
#'                  statistical metrics such as intercepts and spline 
#'                  coefficients.
#' @param data A matrix or dataframe containing the raw data values for each 
#' feature.
#' @param meta A dataframe containing metadata for the data, including time 
#' points.
#' @param main_title The main title to be used for the composite plot of all 
#' features.
#' @return A list containing the composite plot and the number of rows used in 
#' the plot layout.
#' 
#' @importFrom splines ns
#' @importFrom ggplot2 ggplot geom_point geom_line theme_minimal labs theme 
#' scale_x_continuous annotate
#' @importFrom patchwork wrap_plots plot_annotation
#' 
plot_splines <- function(top_table, 
                         data, 
                         meta, 
                         X,   # Was already created from spline_params before
                         main_title,
                         time_unit_label) {
  
  DoF <- which(names(top_table) == "AveExpr") - 1
  time_points <- meta$Time
  
  titles <- data.frame(
    FeatureID = top_table$feature_index,
    feature_names = top_table$feature_names
  )
  
  plot_list <- list()
  
  ## Generate individual plots -------------------------------------------------
  for (hit in 1:nrow(top_table)) {
    hit_index <- as.numeric(top_table$feature_index[hit])
    y_values <- data[hit_index, ]
    
    intercept <- top_table$intercept[hit]
    
    spline_coeffs <- as.numeric(top_table[hit, 1:DoF])
    
    Time <- seq(meta$Time[1], meta$Time[length(meta$Time)], length.out = 100)
    
    fitted_values <- X %*% spline_coeffs + intercept
    
    plot_data <- data.frame(Time = time_points, Y = y_values)
    
    plot_spline <- data.frame(Time = Time, Fitted = fitted_values)
    
    x_max <- as.numeric(max(time_points))
    x_extension <- x_max * 0.05 
    
    p <- ggplot2::ggplot() +
      geom_point(data = plot_data, aes(x = Time, y = Y), color = 'blue') +
      geom_line(data = plot_spline, aes(x = Time, y = Fitted), 
                color = 'red') +
      theme_minimal() +
      scale_x_continuous(limits = c(min(time_points), x_max + x_extension)) +
      labs(x = paste0("Time ", time_unit_label), y = "Intensity")
    
    matched_row <- subset(titles, FeatureID == hit_index)
    title <- as.character(matched_row$feature_name)
    if (is.na(title)) {
      title <- paste("feature:", hit_index)
    }
    
    p <- p + labs(title = title, 
                  x = paste0("Time ", time_unit_label), y = "Intensity") +
      theme(plot.title = element_text(size = 4),
            axis.title.x = element_text(size = 8), 
            axis.title.y = element_text(size = 8)) +
      annotate("text", x = x_max + (x_extension / 2), y = 
                 max(fitted_values, na.rm = TRUE),
               label = "",
               hjust = 0.5, vjust = 1, size = 3.5, angle = 0, color = "black")
    
    plot_list[[length(plot_list) + 1]] <- p
  }
  
  ## Generate the combined plot ------------------------------------------------
  if(length(plot_list) > 0) {           
    num_plots <- length(plot_list)
    ncol <- 3
    nrows <- ceiling(num_plots / ncol)
    
    composite_plot <- patchwork::wrap_plots(plot_list, ncol = 3) + 
      patchwork::plot_annotation(title = main_title,
                                 theme = theme(plot.title = 
                                                 element_text(hjust = 0.5, 
                                                              size = 14)))
    return(list(composite_plot = composite_plot, nrows = nrows))
  } else {
    stop("plot_list in function plot_splines splinetime package has length 0!")
  }
}


#' Build Cluster Hits Report
#'
#' @description
#' Generates an HTML report for clustered hits, including plots and 
#' spline parameter details, with a table of contents.
#'
#' @param header_section A character string containing the HTML header section.
#' @param plots A list of ggplot2 plot objects.
#' @param plots_sizes A list of integers specifying the size of each plot.
#' @param level_headers_info A list of header information for each level.
#' @param spline_params A list of spline parameters.
#' @param mode A character string specifying the mode 
#'            ('isolated' or 'integrated').
#' @param output_file_path A character string specifying the path to save the 
#'                         HTML report.
#'
#' @return No return value, called for side effects.
#'
#' @examples
#' header_section <- "<html><head></head><body>"
#' plots <- list(ggplot2::ggplot(mtcars, ggplot2::aes(mpg, cyl)) + 
#' ggplot2::geom_point())
#' plots_sizes <- list(2)
#' level_headers_info <- list(list("Level 1", 0))
#' spline_params <- list(spline_type = "n", dof = 3)
#' mode <- "isolated"
#' output_file_path <- "report.html"
#' build_cluster_hits_report(header_section, plots, plots_sizes, 
#' level_headers_info, 
#'                          spline_params, mode, output_file_path)
#'
#' @seealso
#' \code{\link{plot2base64}}, \code{\link{create_progress_bar}}
#' 
build_cluster_hits_report <- function(header_section, 
                                      plots, 
                                      plots_sizes, 
                                      level_headers_info = level_headers_info,
                                      spline_params = spline_params,
                                      mode,
                                      output_file_path) {  
  
  content_with_plots <- paste(header_section, "<!--TOC-->", sep="\n")
  
  toc <- "<div id='toc' style='text-align: center; display: block; margin: auto;
          width: 80%;'> 
        <h2 style='font-size: 40px;'>Table of Contents</h2>
        <ul style='display: inline-block; text-align: left;'>"
  
  section_header_style <- "font-size: 70px; color: #001F3F; text-align: center;"
  toc_style <- "font-size: 30px;"
  
  current_header_index <- 1
  
  pb <- create_progress_bar(plots)
  # Generate the sections and plots
  for (index in seq_along(plots)) {
    if (current_header_index <= length(level_headers_info)) {
      header_info <- level_headers_info[[current_header_index]]
      header_placement <- header_info[[2]]
      
      if (index - 1 == header_placement) {
        section_header <- sprintf("<h2 style='%s' id='section%d'>%s</h2>", 
                                  section_header_style, index, header_info[[1]])
        content_with_plots <- paste(content_with_plots, section_header, 
                                    sep="\n")
        
        if (mode == "integrated") {
          j <- 1
        } else {      # mode == "isolated" or mode == NA
          j <- index
        }
        
        if (!is.null(spline_params$spline_type) && 
            length(spline_params$spline_type) >= j) {
          spline_params$spline_type[j] <- spline_params$spline_type[j]
        } else {
          spline_params$spline_type[j] <- NA
        }
        
        if (!is.null(spline_params$degree) && 
            length(spline_params$degree) >= j) {
          spline_params$degree[j] <- spline_params$degree[j]
        } else {
          spline_params$degree[j] <- NA
        }
        
        if (!is.null(spline_params$dof) && 
            length(spline_params$dof) >= j) {
          spline_params$dof[j] <- spline_params$dof[j]
        } else {
          spline_params$dof[j] <- NA
        }
        
        if (!is.null(spline_params$knots) && 
            length(spline_params$knots) >= j) {
          spline_params$knots[j] <- spline_params$knots[j]
        } else {
          spline_params$knots[j] <- NA
        }
        
        if (!is.null(spline_params$bknots) && 
            length(spline_params$bknots) >= j) {
          spline_params$bknots[j] <- spline_params$bknots[j]
        } else {
          spline_params$bknots[j] <- NA
        }
        
        
        if (spline_params$spline_type[j] == "b") {
          spline_params_info <- 
            sprintf("<p style='text-align: center; font-size: 30px;'>
                    <span style='color: blue;'>Spline-type:</span> B-spline<br>
                    <span style='color: blue;'>Degree:</span> %s<br>
                    <span style='color: blue;'>DoF:</span> %s<br>
                    <span style='color: blue;'>Knots:</span> %s<br>
                    <span style='color: blue;'>Boundary-knots:</span> %s</p>", 
                    spline_params$degree[j], spline_params$dof[j], 
                    spline_params$knots[j], spline_params$bknots[j])
        } else {    # == "n"
          spline_params_info <- 
            sprintf("<p style='text-align: center; font-size: 30px;'>
                    <span style='color: blue;'>Spline-type:</span> Natural cubic
                    spline<br>
                    <span style='color: blue;'>DoF:</span> %s<br>
                    <span style='color: blue;'>Knots:</span> %s<br>
                    <span style='color: blue;'>Boundary-knots:</span> %s</p>", 
                    spline_params$dof[j], spline_params$knots[j], 
                    spline_params$bknots[j])
          
        }
        
        content_with_plots <- paste(content_with_plots, spline_params_info, 
                                    sep="\n")
        
        toc_entry <- sprintf("<li style='%s'><a href='#section%d'>%s</a></li>", 
                             toc_style, index, header_info[[1]])
        toc <- paste(toc, toc_entry, sep="\n")
        
        current_header_index <- current_header_index + 1
      }
    }
    
    # Process each plot
    plot <- plots[[index]]
    plot_size <- plots_sizes[[index]]
    img_tag <- plot2base64(plot, plot_size)
    content_with_plots <- paste(content_with_plots, img_tag, sep="\n")
    pb$tick()
  }
  
  # Close the Table of Contents
  toc <- paste(toc, "</ul></div>", sep="\n")
  
  # Insert the Table of Contents at the placeholder
  content_with_plots <- gsub("<!--TOC-->", toc, content_with_plots)
  
  # Append the final closing tags for the HTML body and document
  content_with_plots <- paste(content_with_plots, "</body></html>", sep="\n")
  
  # Ensure the directory exists
  dir_path <- dirname(output_file_path)
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE)
  }
  
  # Write the HTML content to file
  writeLines(content_with_plots, output_file_path)
}


# Level 3 internal functions ---------------------------------------------------


#' Check Dataframe
#'
#' @description
#' Validates that the dataframe contains all required columns with the correct 
#' data types.
#'
#' @param df A dataframe to check.
#'
#' @return TRUE if the dataframe is valid, otherwise an error is thrown.
#'
#' @examples
#' df <- data.frame(
#'   AveExpr = runif(10),
#'   F = runif(10),
#'   P.Value = runif(10),
#'   adj.P.Val = runif(10),
#'   feature_index = as.integer(1:10),
#'   feature_names = letters[1:10],
#'   intercept = runif(10)
#' )
#' check_dataframe(df)
#' 
check_dataframe <- function(df) {
  
  # Define the required columns and their expected types
  required_columns <- list(
    AveExpr = "numeric",
    F = "numeric",
    P.Value = "numeric",
    adj.P.Val = "numeric",
    feature_index = "integer",
    feature_names = "character",
    intercept = "numeric"
  )
  
  # Check if all required columns are present
  missing_columns <- setdiff(names(required_columns), names(df))
  if (length(missing_columns) > 0) {
    stop(paste("Missing columns:", paste(missing_columns, collapse = ", ")))
  }
  
  # Check if columns have the correct type
  for (col in names(required_columns)) {
    if (!inherits(df[[col]], required_columns[[col]])) {
      stop(paste("Column", col, "must be of type", required_columns[[col]]))
    }
  }
  
  return(TRUE)
}

 
#' Calculate Curve Values Based on Top Table Filter
#'
#' @description This function filters entries from a given top table based on 
#' an adjusted p-value threshold,
#' performs spline interpolation using specified degrees of freedom, and 
#' calculates curve values 
#' for the selected entries at predefined time points. The function is 
#' internal and not exported.
#'
#' @param top_table A data frame containing data with a column for adjusted 
#' p-values and 
#'                  expression averages which indicate the number of degrees 
#'                  of freedom.
#' @param adj_pthreshold The threshold for filtering entries based on adjusted
#' p-values.
#' @param level The specific level of the condition to filter on in the 
#' metadata.
#' @param meta Metadata containing time points and conditions.
#' @param condition The name of the condition column in the metadata to filter 
#' on.
#' @return A list containing two elements: `curve_values`, a data frame of 
#' curve values for each filtered entry, and `smooth_timepoints`, the time
#' points at which curves were evaluated.
#' 
#' @importFrom dplyr select all_of
#' @importFrom splines ns
#' 
get_curve_values <- function(top_table,
                             adj_pthreshold, 
                             level, 
                             meta, 
                             condition,
                             spline_params,
                             mode) {
  
  spline_results_hits <- subset(top_table, adj.P.Val < adj_pthreshold)
  
  subset_meta <- meta[meta[[condition]] == level, ]
  
  if (mode == "isolated") {
    level_index <- match(level, unique(meta[[condition]]))
  }
  else if (mode == "integrated") {
    level_index <- 1   # Different spline params not supported for this mode
  }
  
  smooth_timepoints <- seq(subset_meta$Time[1],
                           subset_meta$Time[length(subset_meta$Time)],
                           length.out = 100)
  
  args <- list(x = smooth_timepoints, intercept = FALSE)
  
  if (!is.null(spline_params$dof)) {
    args$df <- spline_params$dof[level_index]
  } else {
    args$knots <- spline_params$knots[[level_index]]
  }
  
  if (!is.null(spline_params$bknots)) {
    args$Boundary.knots <- spline_params$bknots[[level_index]]
  }
  
  
  if (spline_params$spline_type[level_index] == "b") {
    args$degree <- spline_params$degree[level_index]
    X <- do.call(splines::bs, args)
  } else {                                          # natural cubic splines
    X <- do.call(splines::ns, args)
  }
  
  DoF <- which(names(top_table) == "AveExpr") - 1
  
  columns_to_select <- 1:DoF
  
  splineCoeffs <- spline_results_hits %>%
    dplyr::select(all_of(1:DoF)) %>%
    as.matrix()
  
  curve_values <- matrix(nrow = nrow(splineCoeffs),
                         ncol = length(smooth_timepoints))
  
  for(i in 1:nrow(splineCoeffs)) {
    current_coeffs <- matrix(splineCoeffs[i, ], ncol = ncol(splineCoeffs),
                             byrow = TRUE)
    
    curve_values[i, ] <- current_coeffs %*% t(X)
  }
  
  curve_values <- as.data.frame(curve_values)
  rownames(curve_values) <- rownames(splineCoeffs)
  list(curve_values = curve_values, 
       smooth_timepoints = smooth_timepoints,
       X = X)
}


#' Normalize Curve Values
#'
#' @description This function normalizes each row in a data frame or matrix 
#' of curve values. 
#' Normalization is performed so that each row's values range from 0 
#' (corresponding to the 
#' minimum value of the row) to 1 
#' (corresponding to the maximum value of the row).
#'
#' @param curve_values A data frame or matrix of curve values where each row 
#' represents 
#'        a curve and each column a time point.
#' @return A data frame or matrix with the same dimensions as the input, where
#'  each row 
#'         has been normalized.
#' @examples
#' data <- matrix(runif(100), nrow=10)
#' normalized_data <- normalize_curves(data)
#' 
normalize_curves <- function(curve_values) {
  
  normalized_curves <- apply(curve_values, 1, function(row) {
    (row - min(row)) / (max(row) - min(row))
  })
  
  normalized_curves <- t(normalized_curves)
  curve_values[,] <- normalized_curves
  curve_values
}

 
#' Hierarchical Clustering of Curve Values
#'
#' @description Performs hierarchical clustering on given curve values. 
#' It can automatically 
#' determine the optimal number of clusters using silhouette analysis or use a 
#' specified number. The function adjusts the provided top_table with cluster 
#' assignments.
#'
#' @param curve_values A matrix or data frame of curve values to cluster.
#' @param k The number of clusters to use or "auto" to automatically determine 
#'          the optimal number using silhouette width analysis.
#' @param smooth_timepoints Numeric vector of time points corresponding to 
#'                          columns in curve_values.
#' @param top_table Data frame to be updated with cluster assignments.
#' @return A list containing clustering results and the modified top_table.
#' 
#' @importFrom stats dist hclust cutree
#' @importFrom cluster silhouette
#' 
hierarchical_clustering <- function(curve_values, 
                                    k, 
                                    smooth_timepoints,
                                    top_table) {
  
  distance_matrix <- stats::dist(curve_values, method = "euclidean")
  hc <- stats::hclust(distance_matrix, method = "complete")
  
  if (is.character(k) && k == "auto") {
    # Calculate silhouette width for a range of clusters
    max_clusters <- 8
    sil_widths <- numeric(max_clusters - 1)
    for (i in 2:max_clusters) {
      temp_clusters <- stats::cutree(hc, k = i)
      silhouette_score <- 
        mean(cluster::silhouette(temp_clusters, distance_matrix)[, "sil_width"])
      
      adjusted_score <- silhouette_score + (0.02 * log(i)) # scaling factor
      sil_widths[i - 1] <- adjusted_score
    }
    
    # Find the index of the maximum adjusted silhouette score
    best_k_index <- which.max(sil_widths)
    k <- best_k_index + 1  # because index shift due to starting at 2 clusters
    
    cluster_assignments <- stats::cutree(hc, k = k)
  } else if (is.numeric(k)) {
    cluster_assignments <- stats::cutree(hc, k = k)
  }
  
  clustered_hits <- data.frame(cluster = cluster_assignments)
  top_table_hits <- dplyr::filter(top_table, adj.P.Val < 0.05)
  clustered_hits$feature <- top_table_hits$feature_index
  clustered_hits <- clustered_hits[, c("feature", "cluster")]
  
  colnames(curve_values) <- smooth_timepoints
  curve_values$cluster <- cluster_assignments
  
  top_table$cluster <- NA
  top_table$cluster[1:nrow(clustered_hits)] <-
    as.integer(clustered_hits$cluster)
  
  group_clustering <- list(clustered_hits = clustered_hits,
                           hc = hc,
                           curve_values = curve_values,
                           top_table = top_table,
                           clusters = k)
}
