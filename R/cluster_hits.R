#' cluster_hits.R contains the exported package function cluster_hits and all
#' the functions that make up the functionality of cluster_hits. cluster_hits
#' clusters the hits of a time series omics datasets (the features that were
#' significantly changed over the time course) with hierarchical clustering of
#' the spline shape.


# Exported function: cluster_hits() --------------------------------------------


#' Cluster Hits from Top Tables
#'
#' Performs clustering on hits from top tables generated by differential
#' expression analysis.
#' This function filters hits based on adjusted p-value thresholds, extracts
#' spline coefficients for
#' significant features, normalizes these coefficients, and applies hierarchical
#' clustering. The results,
#' including clustering assignments and normalized spline curves, are saved in a
#' specified directory and
#' compiled into an HTML report.
#'
#' @param top_tables A list of data frames, each representing a top table from
#' differential expression analysis, containing at least 'adj.P.Val' and
#' expression data columns.
#' @param data The original expression dataset used for differential expression
#' analysis.
#' @param meta A dataframe containing metadata corresponding to the `data`,
#' must include a 'Time' column and any columns specified by `conditions`.
#' @param condition Character of length 1 specifying the column name in `meta`
#' used to define groups for analysis.
#' @param adj_pthresholds Numeric vector of p-value thresholds for filtering
#' hits in each top table.
#' @param clusters Character or integer vector specifying the number of
#' clusters or 'auto' for automatic estimation.
#' @param report_info A character string to be printed at the top of the report.
#' @param spline_params A list of spline parameters for the analysis.
#' @param design A character of length 1 representing the limma design formula
#' @param meta_batch_column A character string specifying the column name in
#' the metadata used for batch effect removal.
#' @param meta_batch2_column A character string specifying the second column 
#'                           name in the metadata used for batch effect removal.
#' @param time_unit A character string specifying the time unit label for plots
#' (e.g., 'm' for minutes).
#' @param report_dir Character string specifying the directory path where the
#' HTML report and any other output files should be saved.
#' @param report Boolean TRUE or FALSE value specifing if a report should be
#' generated.
#'
#' @return A list where each element corresponds to a group factor and contains
#' the clustering results,
#'         including `clustered_hits` data frame, hierarchical clustering object
#'         `hc`, `curve_values`
#'         data frame with normalized spline curves, and `top_table` with
#'         cluster assignments.
#'
#' @examples
#' \dontrun{
#'   cluster_results <- cluster_hits(top_tables, data, meta, c("GroupFactor"),
#'                                   c(0.05),
#'                                   c(3), "path/to/report/dir")
#' }
#'
#' @seealso \code{\link[limma]{topTable}}, \code{\link[stats]{hclust}}
#'
#' @export
#'
cluster_hits <- function(top_tables,  # limma topTable (from run_limma_splines)
                         data,
                         meta,
                         design,      # limma design formula
                         condition,   # meta factor column
                         report_info,   # Gets printed on top of the report
                         spline_params = list(spline_type = c("n"),
                                              dof = c(2L)),
                         adj_pthresholds = c(0.05),
                         clusters = c("auto"),
                         meta_batch_column = NA,   # to remove batch effect
                         meta_batch2_column = NA,   # second batch effect
                         time_unit = "min",    # For the plot labels
                         report_dir = here::here(),
                         report = TRUE) {

  mode <- determine_analysis_mode(design,
                                  condition)

  args <- lapply(as.list(match.call()[-1]), eval, parent.frame())
  args$mode <- mode
  check_null_elements(args)
  input_control <- InputControl$new(args)
  input_control$auto_validate()

  data_report <- rownames_to_column(data, var = "Feature_name")

  # feature_names are in top_tables
  matrix_and_feature_names <- process_data(data)
  data <- matrix_and_feature_names$data

  # To set the default p-value threshold for ALL levels.
  if (is.numeric(adj_pthresholds) &&
      length(adj_pthresholds) == 1 && adj_pthresholds[1] == 0.05) {
    levels <- unique(meta[[condition]])
    adj_pthresholds <- rep(adj_pthresholds[1], length(levels))
  }

  within_level_top_tables <-
    filter_top_tables(top_tables = top_tables,
                      adj_pthresholds = adj_pthresholds,
                      meta = meta,
                      condition = condition)

  huge_table_user_prompter(within_level_top_tables)

  all_levels_clustering <-
    perform_clustering(top_tables = within_level_top_tables,
                       clusters = clusters,
                       meta = meta,
                       condition = condition,
                       spline_params = spline_params,
                       mode = mode)

  report_info$limma_design <- c(design)
  report_info$meta_condition <- c(condition)
  report_info$meta_batch <- paste(meta_batch_column,
                                  meta_batch2_column,
                                  sep = ", ")

  if (report) {
    plots <-
      make_clustering_report(all_levels_clustering = all_levels_clustering,
                             condition = condition,
                             data = data,
                             meta = meta,
                             spline_params = spline_params,
                             report_dir = report_dir,
                             mode = mode,
                             report_info = report_info,
                             data_report = data_report,
                             design = design,
                             meta_batch_column = meta_batch_column,
                             meta_batch2_column = meta_batch2_column,
                             time_unit = time_unit)
  } else {
    plots <- "no plots, because report arg of cluster_hits() was set to FALSE"
  }

  # Leave a message for the user instead of just NA.
  all_levels_clustering <- lapply(all_levels_clustering, function(x) {
    if (is.logical(x)) {
      return("No result for this level, because the top_table had < 2 hits")
    } else {
      return(x)
    }
  })
  
  clustered_hits_levels <- list()
  
  for (i in seq_along(all_levels_clustering)) {
    clustering_level <- all_levels_clustering[[i]]
    element_name <- names(all_levels_clustering)[i]
    
    if (any(is.character(clustering_level))) {
      clustered_hits_levels[[element_name]] <- 
        clustering_level
    }
    else {                                       # normal list result
      clustered_hits_levels[[element_name]] <- 
        clustering_level$clustered_hits
    }
  }
  
  
  list(all_levels_clustering = all_levels_clustering,
       plots = plots,
       clustered_hits_levels = clustered_hits_levels)
}



# Level 1 internal functions ---------------------------------------------------


filter_top_tables <- function(top_tables,
                              adj_pthresholds,
                              meta,
                              condition) {

  result <- check_between_level_pattern(top_tables)

  if (result$between_levels) {                     # between_level analysis
    if (result$index_with_pattern == 1) {
      within_level_top_tables_index <- 2
      between_level_top_tables_index <- 1
    } else {                        # between level top_tables are at index 2
      within_level_top_tables_index <- 1
      between_level_top_tables_index <- 2
    }

    within_level_top_tables <- top_tables[[within_level_top_tables_index]]
    between_level_top_tables <- top_tables[[between_level_top_tables_index]]

  } else {                                  # no between level analysis
    within_level_top_tables <- top_tables
  }


  for (i in seq_along(within_level_top_tables)) {

    within_level_top_table <- within_level_top_tables[[i]]
    level <- unique(meta[[condition]])[i]

    if (result$between_levels) {
      hit_indices <- get_level_hit_indices(between_level_top_tables,
                                           level,
                                           adj_pthresholds)
    } else {    # within level
      hit_indices <- within_level_top_table[["feature_index"]][
        within_level_top_table[["adj.P.Val"]] < adj_pthresholds[i]
      ]
    }

    if (length(hit_indices) == 0) {
      stop(paste("No features in level", level ,"have an adj.P.Val <",
                 adj_pthresholds[i]),
           call. = FALSE)
    }

    top_table_filtered <-
      within_level_top_table[within_level_top_table[["feature_index"]]
                             %in% hit_indices, ]

    if (nrow(top_table_filtered) < 2) {
      message(paste("Level", level, "has < 2 hits. Skipping clustering for",
                    "this level"))
      within_level_top_tables[[i]] <- NA
    } else {
      within_level_top_tables[[i]] <- top_table_filtered
    }

  }

  if (all(is.na(within_level_top_tables))) {
    stop("All levels have < 2 hits. Cannot run clustering.", call. = FALSE)
  }
  
  # within_level_top_tables <- 
  #   within_level_top_tables[!sapply(within_level_top_tables, is.logical)]
  within_level_top_tables
}


#' Check if any table in a list has more than 300 rows and prompt user for 
#' input.
#'
#' This function iterates over a list of tables and checks if any table has
#'  more than 300 rows.
#' If such a table is found, it prompts the user to proceed or stop.
#'
#' @param tables A list of data frames.
#' @return NULL. This function is used for its side effects (prompting the 
#' user and potentially stopping the script).
#' 
huge_table_user_prompter <- function(tables) {
  
  for (i in seq_along(tables)) {

    if (any(is.logical(tables[[i]]))) {
      next
    }
    
    if (nrow(tables[[i]]) > 300) {
      # Prompt the user for input
      while (TRUE) {
        user_input <- readline(prompt = paste("The table", names(tables)[i], 
                                              "has more than 300 rows. Do you", 
                                              "want to proceed? (y/n): "))
        user_input <- tolower(user_input)
        
        # Check user input
        if (user_input == 'y') {
          # Proceed
          print("Proceeding...")
          break  
        } else if (user_input == 'n') {
          stop("Script stopped. User chose not to proceed.", call. = FALSE)
        } else {
          # Invalid input, ask the user again
          cat(paste("Invalid input. Please type 'y' to proceed or 'n' to stop", 
                    "the script.\n"))
        }
      }
    }
  }
}


#' Perform Clustering
#'
#' @description
#' Performs clustering on top tables using specified p-values and clusters
#' for each level within a condition.
#'
#' @param top_tables A list of top tables from limma analysis.
#' @param clusters A list specifying clusters or "auto" for automatic
#' estimation.
#' @param meta A dataframe containing metadata.
#' @param condition A character string specifying the condition.
#' @param spline_params A list of spline parameters for the analysis.
#' @param mode A character string specifying the mode
#' ('isolated' or 'integrated').
#'
#' @return A list of clustering results for each level within the condition.
#'
#' @seealso
#' \code{\link{process_level_cluster}}
#'
perform_clustering <- function(top_tables,
                               clusters,
                               meta,
                               condition,
                               spline_params,
                               mode) {

  levels <- unique(meta[[condition]])

  if (is.character(clusters) && length(clusters) == 1 && clusters[1] == "auto")
  {
    clusters <- rep(clusters[1], length(levels))

  }

  all_levels_clustering <- mapply(process_level_cluster,
                                  top_tables,
                                  clusters,
                                  levels,
                                  MoreArgs = list(meta = meta,
                                                  condition = condition,
                                                  spline_params = spline_params,
                                                  mode = mode),
                                  SIMPLIFY = FALSE)  # Return a list
}


#' Make Clustering Report
#'
#' @description
#' Generates a detailed clustering report including heatmaps, dendrograms,
#' curve plots, and consensus shapes for each level within a condition.
#'
#' @param all_levels_clustering A list containing clustering results for each
#' level within a condition.
#' @param condition A character string specifying the condition.
#' @param data A matrix of data values.
#' @param meta A dataframe containing metadata.
#' @param spline_params A list of spline parameters for the analysis.
#' @param report_dir A character string specifying the report directory.
#' @param mode A character string specifying the mode
#' ('isolated' or 'integrated').
#' @param report_info An object containing report information.
#' @param data_report A dataframe containing the data used in the limma splines
#'                    analysis. This data will be embedded in the HTML report,
#'                    so that it can be downloaded from there.
#' @param design A string representing the limma design formula
#' @param meta_batch_column A character string specifying the meta batch column.
#' @param meta_batch2_column A character string specifying the second meta 
#'                           batch column.
#' @param time_unit A character string specifying the time unit
#' ('s', 'm', 'h', 'd').
#'
#' @return No return value, called for side effects.
#'
#' @seealso
#' \code{\link{removeBatchEffect}}, \code{\link{plot_heatmap}},
#' \code{\link{plot_dendrogram}}, \code{\link{plot_all_shapes}},
#' \code{\link{plot_consensus_shapes}}, \code{\link{plot_splines}},
#' \code{\link{generate_report_html}}
#'
#' @importFrom limma removeBatchEffect
#' @importFrom dplyr filter
#' @importFrom stats na.omit
#'
make_clustering_report <- function(all_levels_clustering,
                                   condition,
                                   data,
                                   meta,
                                   spline_params,
                                   report_dir,
                                   mode,
                                   report_info,
                                   data_report,
                                   design,
                                   meta_batch_column,
                                   meta_batch2_column,
                                   time_unit) {

  # Optionally remove the batch-effect with the batch column and design matrix
  # For mode == "integrated", the batch-effect is removed from the whole data
  # For mode == "isolated", the batch-effect is removed for every level
  datas <-
    remove_batch_effect_cluster_hits(data = data,
                                     meta = meta,
                                     condition = condition,
                                     meta_batch_column = meta_batch_column,
                                     meta_batch2_column = meta_batch2_column,
                                     design = design,
                                     mode = mode,
                                     spline_params = spline_params)


  # To extract the stored value for the potential auto cluster decision.
  clusters <- c()
  for (i in seq_along(all_levels_clustering)) {

    if (is.null(all_levels_clustering[[i]]) ||
        all(is.na(all_levels_clustering[[i]]))) {
      next
    }

    clusters <- c(clusters, as.integer(all_levels_clustering[[i]]$clusters))
    all_levels_clustering[[i]]$clusters <- NULL
  }

  if (!dir.exists(report_dir)) {
    dir.create(report_dir)
  }

  time_unit_label <- paste0("[", time_unit, "]")

  heatmaps <- plot_heatmap(datas = datas,
                           meta = meta,
                           mode = mode,
                           condition = condition,
                           all_levels_clustering = all_levels_clustering,
                           time_unit_label = time_unit_label)

  # log2_intensity_shape <- plot_log2_intensity_shapes()

  level_headers_info <- list()
  plots <- list()
  plots_sizes <- list()
  q <- 0

  for (i in seq_along(all_levels_clustering)) {

    # When a level has < 2 hits
    if (is.null(all_levels_clustering[[i]]) ||
        all(is.na(all_levels_clustering[[i]]))) {
      next
    } else {
      q <- q + 1
    }

    level_clustering <- all_levels_clustering[[i]]

    levels <- unique(meta[[condition]])

    if (length(levels) >= i) {

      ith_unique_value <- levels[i]

      # Construct header name
      header_name <- ith_unique_value

      nr_hits <- nrow(level_clustering$clustered_hits)

      header_info <- list(header_name = header_name,
                          nr_hits = nr_hits)

      level_headers_info[[i]] <- header_info
    }

    curve_values <- level_clustering$curve_values

    dendrogram <- plot_dendrogram(level_clustering$hc,
                                  clusters[q])

    p_curves <- plot_all_shapes(curve_values, time_unit_label)

    consensus_shapes <- plot_consensus_shapes(curve_values, time_unit_label)

    top_table <- level_clustering$top_table
    levels <- as.character(unique(meta[[condition]]))

    col_indices <- which(meta[[condition]] == levels[i])

    if (mode == "integrated") {
      data_level <- datas[[i]][, col_indices]
    } else {                                    # mode == "isolated"
      data_level <- datas[[i]]
    }

    meta_level <- meta %>% dplyr::filter(meta[[condition]] == levels[i])

    composite_plots <- list()
    nrows <- list()

    
    for (nr_cluster in unique(stats::na.omit(top_table$cluster))) {

      nr_of_hits <- sum(level_clustering$clustered_hits$cluster == nr_cluster,
                        na.rm = TRUE)
      main_title <- paste("Cluster", nr_cluster, " | Hits:", nr_of_hits, 
                          sep = " ")

      top_table_cluster <- top_table %>%
        dplyr::filter(!!rlang::sym("cluster") == nr_cluster)

      X <- level_clustering$X

      plot_splines_result <- plot_splines(top_table_cluster,
                                          data_level,
                                          meta_level,
                                          X,
                                          main_title,
                                          time_unit_label)

      composite_plots[[length(composite_plots) + 1]] <-
        plot_splines_result$composite_plot

      nrows[[length(nrows) + 1]] <- plot_splines_result$nrows
    }

    plots <- c(plots,
               "level_header",    # is the signal for the plotting code
               list(dendrogram, p_curves),
               list(consensus_shapes$plot),
               heatmaps[[i]],
               composite_plots)

    # For every plot in plots, this determines the size in the HTML
    plots_sizes <- c(plots_sizes,
                     999,               # dummy size for "next_level" signal
                     1.5,
                     1.5,
                     consensus_shapes$size,
                     1.5,
                     unlist(nrows))
  }
  print("Generating report. This takes a few seconds.")
  generate_report_html(plots = plots,
                       plots_sizes = plots_sizes,
                       level_headers_info = level_headers_info,
                       spline_params = spline_params,
                       report_info = report_info,
                       data = data_report,
                       meta = meta,
                       report_type = "cluster_hits",
                       mode = mode,
                       filename = "report_clustered_hits",
                       report_dir = report_dir)

  return(plots)
}



# Level 2 internal functions ---------------------------------------------------


check_between_level_pattern <- function(top_tables) {

  # Initialize variables
  between_levels <- FALSE
  index_with_pattern <- NA

  # Define the regular expression pattern
  pattern <- ".+_vs_.+"

  # Check if top_tables is a list
  if (is.list(top_tables)) {
    # Iterate over each element in top_tables
    for (i in seq_along(top_tables)) {
      # Check if the element is a list
      if (is.list(top_tables[[i]])) {
        # Get the names of the elements in the inner list
        element_names <- names(top_tables[[i]])
        # Check if all names in the inner list match the pattern
        if (all(grepl(pattern, element_names))) {
          between_levels <- TRUE
          index_with_pattern <- i
          break
        }
      }
    }
  }

  # Return the result as a list
  return(list(between_levels = between_levels,
              index_with_pattern = index_with_pattern))
}


get_level_hit_indices <- function(between_level_top_tables,
                                  level,
                                  adj_pthresholds) {

  # Initialize a vector to store unique feature indices
  unique_hit_indices <- c()

  # Loop through the elements of the list
  for (i in seq_along(between_level_top_tables)) {
    # Get the name of the current data frame
    df_name <- names(between_level_top_tables)[i]

    # Check if the name contains the level string case insensitively
    if (grepl(level, df_name, ignore.case = TRUE)) {
      # Get the current data frame
      within_level_top_table <- between_level_top_tables[[i]]

      # Find the row indices that meet the condition
      hit_indices <-
        which(within_level_top_table[["adj.P.Val"]] < adj_pthresholds[i])

      # Extract the feature indices from the identified rows
      feature_indices <- within_level_top_table[hit_indices, "feature_index"]
      feature_indices <- within_level_top_table[hit_indices,
                                                "feature_index", drop = TRUE]
      unique_hit_indices <- c(unique_hit_indices, feature_indices)
    }
  }

  # Get unique feature indices
  unique_hit_indices <- unique(unique_hit_indices)
}


#' Process Level Cluster
#'
#' @description
#' Processes clustering for a specific level within a condition using the
#' provided top table and spline parameters.
#'
#' @param top_table A dataframe containing the top table results from limma.
#' @param cluster_size The size of clusters to generate.
#' @param level The level within the condition to process.
#' @param meta A dataframe containing metadata.
#' @param condition A character string specifying the condition.
#' @param spline_params A list of spline parameters for the analysis.
#' @param mode A character string specifying the mode
#'            ('isolated' or 'integrated').
#'
#' @return A list containing the clustering results, including curve values and
#'         the design matrix.
#'
#' @seealso
#' \code{\link{get_curve_values}}, \code{\link{normalize_curves}},
#' \code{\link{hierarchical_clustering}}
#'
process_level_cluster <- function(top_table,
                                  cluster_size,
                                  level,
                                  meta,
                                  condition,
                                  spline_params,
                                  mode) {

  # means that it had < 2 hits.
  if (is.null(top_table) || all(is.na(top_table))) {
    return(NA)
  }
  
  curve_results <- get_curve_values(top_table = top_table,
                                    level = level,
                                    meta = meta,
                                    condition = condition,
                                    spline_params = spline_params,
                                    mode = mode)

  normalized_curves <- normalize_curves(curve_results$curve_values)

  clustering_result <-
    hierarchical_clustering(curve_values = normalized_curves,
                            k = cluster_size,
                            smooth_timepoints = curve_results$smooth_timepoints,
                            top_table = top_table)

  clustering_result$X <- curve_results$X
  return(clustering_result)
}


remove_batch_effect_cluster_hits <- function(data,
                                             meta,
                                             condition,
                                             meta_batch_column,
                                             meta_batch2_column,
                                             design,
                                             mode,
                                             spline_params) {

  datas <- list()
  n <- length(unique(meta[[condition]]))
  level_indices <- as.integer(1:n)
  unique_levels <- unique(meta[[condition]])

  if (!is.na(meta_batch_column)) {

    for (level_index in level_indices) {

      # Take only the data from the level for mode == "isolated"
      if (mode == "isolated") {
        level <- unique_levels[level_index]
        level_columns <- which(meta[[condition]] == level)
        data_copy <- data[, level_columns]
        meta_copy <- subset(meta, meta[[condition]] == level)
      } else {
        data_copy <- data   # Take the full data for mode == "integrated"
        meta_copy <- meta
        level_index <- 1L   # spline_params here has only one set of params
      }

      design_matrix <- design2design_matrix(meta = meta_copy,
                                            spline_params = spline_params,
                                            level_index = level_index,
                                            design = design)

      # The batch columns are not allowed to be in the design_matrix for
      # removeBatchEffect. Instead the batch column is specified with batch =
      batch_columns <- grep(paste0("^", meta_batch_column),
                            colnames(design_matrix))
      design_matrix <- design_matrix[, -batch_columns]

      args <- list(
        x = data_copy,
        batch = meta_copy[[meta_batch_column]],
        design = design_matrix
      )

      if (!is.na(meta_batch2_column)) {
        args$batch2 <- meta_copy[[meta_batch2_column]]
      }

      data_copy <- do.call(removeBatchEffect, args)

      # For mode == "integrated", all elements are identical
      datas <- c(datas, list(data_copy))
    }

  } else {          # no meta batch column specified, just return right data

    for (level_index in level_indices) {

      # Take only the data from the level for mode == "isolated"
      if (mode == "isolated") {
        level <- unique_levels[level_index]
        level_columns <- which(meta[[condition]] == level)
        data_copy <- data[, level_columns]
      } else {
        data_copy <- data   # Take the full data for mode == "integrated"
      }

      datas <- c(datas, list(data_copy))
    }
  }
  return(datas)
}


#' Plot Heatmap
#'
#' @description
#' Generates heatmaps for each level within a condition, showing z-scores of
#' log2 intensity values, split by clusters.
#'
#' @param datas A matrix of data values.
#' @param meta A dataframe containing metadata.
#' @param mode A character vector with length 1, specifying the type of limma
#'             design formula (integrated for formulas with interaction effects
#'             between the levels, isolated for formulas where each level is 
#'             analysed in isolation (no interaction effects))
#' @param condition A character string specifying the condition.
#' @param all_levels_clustering A list containing clustering results for each
#' level within the condition.
#' @param time_unit_label A character string specifying the time unit label.
#'
#' @return A list of ComplexHeatmap heatmap objects for each level.
#'
#' @seealso
#' \link[ComplexHeatmap]{Heatmap}, \link[dplyr]{arrange}
#'
#' @importFrom dplyr arrange mutate group_by summarize
#' @importFrom tidyr pivot_longer separate
#' @importFrom ComplexHeatmap Heatmap draw ht_opt
#' @importFrom ggplot2 ggplot geom_line facet_wrap geom_vline ylab theme unit
#' @importFrom ggplot2 theme_bw scale_x_continuous
#' @importFrom grid gpar
#'
plot_heatmap <- function(datas,
                         meta,
                         mode,
                         condition,
                         all_levels_clustering,
                         time_unit_label) {

  BASE_TEXT_SIZE_PT <- 5

  ht_opt(
    simple_anno_size = unit(1.5, "mm"),
    COLUMN_ANNO_PADDING = unit(1, "pt"),
    DENDROGRAM_PADDING = unit(1, "pt"),
    HEATMAP_LEGEND_PADDING = unit(1, "mm"),
    ROW_ANNO_PADDING = unit(1, "pt"),
    TITLE_PADDING = unit(2, "mm"),
    heatmap_row_title_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    heatmap_row_names_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    heatmap_column_title_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    heatmap_column_names_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    legend_labels_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    legend_title_gp = gpar(fontsize = BASE_TEXT_SIZE_PT),
    legend_border = FALSE
  )

  levels <- unique(meta[[condition]])
  heatmaps <- list()

  # Generate a heatmap for every level
  for (i in seq_along(all_levels_clustering)) {

    # When a level has < 2 hits
    if (is.null(all_levels_clustering[[i]]) ||
        all(is.na(all_levels_clustering[[i]]))) {
      heatmaps[[length(heatmaps) + 1]] <- NA
      next
    }

    level_clustering <- all_levels_clustering[[i]]

    clustered_hits <- level_clustering$clustered_hits
    clusters <- clustered_hits %>% dplyr::arrange(!!rlang::sym("cluster"))

    level <- levels[[i]]
    level_indices <- which(meta[[condition]] == level)

    if (mode == "integrated") {
      data_level <- datas[[i]][, level_indices]
    } else {                                    # mode == "isolated"
      data_level <- datas[[i]]
    }

    data_level <- data_level[as.numeric(clusters$feature),]
    z_score <- t(scale(t(data_level)))

    meta_level <- meta[level_indices, ]

    ht <-
      ComplexHeatmap::Heatmap(z_score,
                              name = paste0("left-labels = cluster,", 
                                            "top-labels = time"),
                              use_raster = TRUE,
                              column_split = meta_level$Time,
                              cluster_columns = FALSE,
                              row_split = clusters$cluster,
                              cluster_rows = FALSE,
                              heatmap_legend_param = list(title = "z-score of
                                                                log2 values",
                                                          title_position =
                                                            "lefttop-rot"),
                              row_gap = unit(2, "pt"),
                              column_gap = unit(2, "pt"),
                              # width = unit(2, "mm") * ncol(z_score) +
                              #   5 * unit(2, "pt"),
                              # height = unit(2, "mm") * nrow(z_score) +
                              #   5 * unit(2, "pt"),
                              show_row_names = TRUE,
                              show_column_names = TRUE,
                              column_names_rot = 60,
                              column_names_gp = gpar(fontsize = 5))

    heatmaps[[length(heatmaps) + 1]] <- ht
  }
  heatmaps
}


# plot_log2_intensity_shapes <- function() {
#   # data_to_plot <- data.frame(first_protein_description =
#   #                              rownames(data.matrix.batch.filt.sig),
#   #                            data.matrix.batch.filt.sig) %>%
#
#
#   data_to_plot <- data %>%
#     dplyr::mutate(cluster_number = clusters$cluster) %>%
#     tidyr::pivot_longer(cols = colnames(data.matrix.batch.filt.sig),
#                         names_to = "sample_name",
#                         values_to = "log2_intensity") %>%
#     tidyr::separate(sample_name,
#                     into = c("reactor", "time_point",
#                              "phase_of_fermentation"),
#                     sep = "_") %>%
#     dplyr::mutate(time_to_feed = rep(meta_exp_filt$time_to_feed,
#                                      length(clusters_exp$feature))) %>%
#     dplyr::group_by(first_protein_description) %>%
#     dplyr::mutate(log2_intensity = rescale(log2_intensity))
#
#
#   data_to_plot_mean_protein  <- data_to_plot %>%
#     dplyr::group_by(first_protein_description, time_to_feed) %>%
#     dplyr::mutate(mean_intensity_protein = mean(log2_intensity)) %>%
#     ungroup()
#
#   data_to_plot_mean_tp <- data_to_plot %>%
#     dplyr::group_by(cluster_number, time_to_feed) %>%
#     dplyr::summarise(mean_intensity_tp = mean(log2_intensity))
#
#   clusters_exp %>%
#     count(cluster)
#
#   ggplot2::ggplot(data = data_to_plot_mean_protein) +
#     geom_line(aes(x = time_to_feed, y = mean_intensity_protein,
#                   color = first_protein_description), alpha = 0.5) +
#     geom_line(data = data_to_plot_mean_tp,aes(x = time_to_feed,
#                                               y = mean_intensity_tp),
#               linewidth = 0.8) +
#     facet_wrap(~cluster_number, ncol = 2,
#                labeller = labeller(cluster_number =
#                                      c("1" = "Cluster 1: 32 proteins",
#                                        "2" = "Cluster 2: 48 proteins",
#                                        "3" = "Cluster 3: 68 proteins",
#                                        "4" = "Cluster 4: 29 proteins",
#                                        "5" = "Cluster 5: 17 proteins",
#                                        "6" = "Cluster 6: 13 proteins")))  +
#     geom_vline(xintercept = 0, linetype = 'dashed', color = 'red',
#                linewidth = 0.5) +
#     ylab("normalized log2 intensity") +
#     theme_bw() +
#     theme(legend.position = "none",
#           panel.grid.minor = element_blank()) +
#     scale_x_continuous(breaks = data_to_plot$time_to_feed)
#
#   #
#   # ht= ComplexHeatmap::draw(ht, heatmap_legend_side = "right")
#   #
#   # print(ht)
# }


#' Plot Dendrogram
#'
#' @description
#' Generates a dendrogram plot for hierarchical clustering results,
#' colored by clusters.
#'
#' @param hc A hierarchical clustering object.
#' @param k An integer specifying the number of clusters.
#'
#' @return A ggplot object representing the dendrogram.
#'
#' @seealso
#' \link[dendextend]{color_branches}, \link[dendextend]{as.ggdend},
#' \link[ggplot2]{ggplot2}
#'
#' @importFrom stats as.dendrogram
#' @importFrom stats cutree
#' @importFrom RColorBrewer brewer.pal.info
#' @importFrom RColorBrewer brewer.pal
#' @importFrom dendextend color_branches
#' @importFrom dendextend as.ggdend
#' @importFrom ggplot2 ggplot element_blank
#' @importFrom ggplot2 labs
#' @importFrom ggplot2 theme_minimal
#' @importFrom ggplot2 theme
#'
plot_dendrogram <- function(hc,
                            k) {

  dend <- stats::as.dendrogram(hc)
  clusters <- stats::cutree(hc, k)

  palette_name <- "Set3"
  max_colors_in_palette <-
    RColorBrewer::brewer.pal.info[palette_name, "maxcolors"]

  # Handle cases where k is less than 3 to avoid warnings
  if (k < 3) {
    colors <- RColorBrewer::brewer.pal(3, palette_name)[1:k]
  } else {
    colors <- RColorBrewer::brewer.pal(min(max_colors_in_palette, k),
                                       palette_name)
  }

  if (k > max_colors_in_palette) {
    colors <- rep(colors, length.out = k)
  }

  dend_colored <- dendextend::color_branches(dend, k = k,
                                             labels_colors = colors)

  dend_colored <-
    dendextend::set(dend_colored, "labels",
                    value = rep("",
                                length(dendextend::get_leaves_attr(dend_colored,
                                                                   "label"))))


  ggdend <- dendextend::as.ggdend(dend_colored)
  p_dend <- ggplot2::ggplot(ggdend) +
    ggplot2::labs(title =
                    paste("Hierarchical Clustering Dendrogram Features", 
                          "(colors = clusters)"),
                  x = "", y = "") +
    ggplot2::theme_minimal() +
    ggplot2::theme(axis.text.x = ggplot2::element_blank(),
                   axis.ticks.x = ggplot2::element_blank(),
                   axis.text.y = ggplot2::element_blank(),
                   axis.ticks.y = ggplot2::element_blank())
}



#' Plot All Shapes
#'
#' @description
#' Generates a plot of average curves for each cluster, showing min-max
#' normalized intensities over time.
#'
#' @param curve_values A dataframe containing curve values and cluster
#' assignments.
#' @param time_unit_label A character string specifying the time unit label.
#'
#' @return A ggplot object representing the average curves by cluster.
#'
#' @seealso
#' \code{\link{ggplot2}}
#'
#' @importFrom ggplot2 ggplot geom_line ggtitle xlab ylab scale_color_brewer
#'             theme_minimal
#'
plot_all_shapes <- function(curve_values,
                            time_unit_label) {

  time <- as.numeric(colnames(curve_values)[-length(colnames(curve_values))])

  clusters <- unique(curve_values$cluster)
  average_curves <- data.frame()

  # Loop through each unique cluster value to calculate the average curve
  for (current_cluster in clusters) {
    # Filter rows for the current cluster
    subset_hits <- curve_values[curve_values$cluster == current_cluster, ]
    last_timepoint <- (which(names(curve_values) == "cluster")) - 1
    average_curve <- colMeans(subset_hits[,1:last_timepoint])

    # Create a data frame for the average curve with an additional 'Cluster'
    # column
    curve_df <- data.frame(Time = time, Value = average_curve,
                           cluster = as.factor(current_cluster))

    # Bind the curve data frame to the cumulative data frame
    average_curves <- rbind(average_curves, curve_df)
  }

  average_curves$cluster <-
    factor(average_curves$cluster,
           levels = sort(unique(as.numeric(average_curves$cluster))))

  p_curves <- ggplot2::ggplot(average_curves,
                              aes(x = !!rlang::sym("Time"),
                                  y = !!rlang::sym("Value"),
                                  color =
                                    factor(!!rlang::sym("cluster")))) +
    geom_line() +
    ggtitle("Average Curves by Cluster") +
    xlab(paste0("Time ", time_unit_label)) +
    ylab("min-max normalized values") +
    scale_color_brewer(palette = "Dark2",
                       name = "Cluster") +
    theme_minimal()
}


#' Plot Single and Consensus Splines
#'
#' @description
#' Generates a plot showing individual time series shapes and their consensus
#' (mean) shape.
#'
#' @param time_series_data A dataframe or matrix with time series data.
#' @param title A character string specifying the title of the plot.
#' @param time_unit_label A character string specifying the time unit label.
#'
#' @return A ggplot object representing the single and consensus shapes.
#'
#' @seealso
#' \code{\link{ggplot2}}
#'
#' @importFrom dplyr arrange mutate
#' @importFrom tibble rownames_to_column
#' @importFrom tidyr pivot_longer
#' @importFrom ggplot2 ggplot geom_line scale_colour_manual theme_minimal
#' ggtitle xlab ylab
#' @importFrom rlang sym
#' @importFrom data.table :=
#'
plot_single_and_consensus_splines <- function(time_series_data,
                                              title,
                                              time_unit_label) {

  time_col <- sym("time")
  feature_col <- sym("feature")

  # Convert data to long format with appropriate column names
  df_long <- as.data.frame(t(time_series_data)) %>%
    rownames_to_column(var = "time") %>%
    pivot_longer(cols = -!!time_col, names_to = "feature",
                 values_to = "intensity") %>%
    arrange(!!feature_col) %>%
    mutate(!!time_col := as.numeric(!!time_col))

  # Compute consensus (mean of each column)
  consensus <- colMeans(time_series_data, na.rm = TRUE)
  consensus_df <- data.frame(time = as.numeric(colnames(time_series_data)),
                             consensus = consensus)

  p <- ggplot2::ggplot() +
    geom_line(data = df_long, aes(x = !!rlang::sym("time"),
                                  y = !!rlang::sym("intensity"),
                                  group = !!rlang::sym("feature"),
                                  colour = "Single Shapes"),
              alpha = 0.3, linewidth = 0.5) +
    geom_line(data = consensus_df, aes(x = !!rlang::sym("time"), y = consensus,
                                       colour = "Consensus Shape"),
              linewidth = 1.5) +
    scale_colour_manual("", values = c("Consensus Shape" = "darkblue",
                                       "Single Shapes" = "#6495ED")) +
    theme_minimal() +
    labs(
      title = title,
      x = paste("Time ", time_unit_label),
      y = "Value") +
    # ggtitle(title) +
    theme(legend.position = "none")
}


#' Plot Consensus Shapes
#'
#' @description
#' Generates composite plots of single and consensus shapes for each cluster
#' of curve values.
#'
#' @param curve_values A dataframe containing curve values and cluster
#'  assignments.
#' @param time_unit_label A character string specifying the time unit label.
#'
#' @return A list containing the composite plot of consensus shapes and its
#' size.
#'
#' @seealso
#' \code{\link{plot_single_and_consensus_splines}}, \code{\link{patchwork}}
#'
plot_consensus_shapes <- function(curve_values,
                                  time_unit_label) {

  clusters <- sort(unique(curve_values$cluster))
  # time <- as.numeric(colnames(curve_values)[-length(colnames(curve_values))])
  plots <- list()
  for (current_cluster in clusters) {
    subset_df <- subset(curve_values, curve_values$cluster == current_cluster)
    subset_df$cluster <- NULL
    nr_of_hits <- nrow(subset_df)
    current_title <- paste("Cluster", current_cluster, 
                           "| Hits:", nr_of_hits,
                           sep = " ")

    plots[[length(plots) + 1]] <-
      plot_single_and_consensus_splines(subset_df,
                                        current_title,
                                        time_unit_label)
  }

  composite_consensus_shapes_plot <-
    patchwork::wrap_plots(plots, ncol = 2) +
    patchwork::plot_annotation(
      title = "min-max normalized cluster consensus shapes",
      theme = ggplot2::theme(plot.title = element_text(hjust = 0.5, size = 14))
    )

  list(plot = composite_consensus_shapes_plot,
       size = length(plots)/2)
}


#' Plot Splines for Features Based on Top Table Information
#'
#' @description This function generates plots for each feature listed in the
#' top table using spline
#' interpolation for fitted values. It creates individual plots for each feature
#' and combines
#' them into a single composite plot. The function is internal and not exported.
#'
#' @param top_table A dataframe containing the indices and names of features,
#' along with their
#'                  statistical metrics such as intercepts and spline
#'                  coefficients.
#' @param data A matrix or dataframe containing the raw data values for each
#' feature.
#' @param meta A dataframe containing metadata for the data, including time
#' points.
#' @param X The limma design matrix that defines the experimental conditions.
#' @param main_title The main title to be used for the composite plot of all
#' features.
#' @param time_unit_label A string shown in the plots as the unit for the time,
#' such as min or hours.
#'
#' @return A list containing the composite plot and the number of rows used in
#' the plot layout.
#'
#' @importFrom splines ns
#' @importFrom ggplot2 ggplot geom_point geom_line theme_minimal labs theme
#' scale_x_continuous annotate
#' @importFrom patchwork wrap_plots plot_annotation
#'
plot_splines <- function(top_table,
                         data,
                         meta,
                         X,   # Was already created from spline_params before
                         main_title,
                         time_unit_label) {

  # Sort so that HTML reports are easier to read and comparisons are easier.
  top_table <- top_table %>% dplyr::arrange(feature_names)

  DoF <- which(names(top_table) == "AveExpr") - 1
  time_points <- meta$Time

  titles <- data.frame(
    FeatureID = top_table$feature_index,
    feature_names = top_table$feature_names
  )

  plot_list <- list()

  ## Generate individual plots -------------------------------------------------
  for (hit in 1:nrow(top_table)) {
    hit_index <- as.numeric(top_table$feature_index[hit])
    y_values <- data[hit_index, ]

    intercept <- top_table$intercept[hit]

    spline_coeffs <- as.numeric(top_table[hit, 1:DoF])

    Time <- seq(meta$Time[1], meta$Time[length(meta$Time)], length.out = 100)

    fitted_values <- X %*% spline_coeffs + intercept

    plot_data <- data.frame(Time = time_points, Y = y_values)

    plot_spline <- data.frame(Time = Time, Fitted = fitted_values)

    x_max <- as.numeric(max(time_points))
    x_extension <- x_max * 0.05

    p <- ggplot2::ggplot() +
      geom_point(data = plot_data, aes(x = Time,
                                       y = !!rlang::sym("Y")),
                 color = 'blue') +
      geom_line(data = plot_spline, aes(x = Time, y = !!rlang::sym("Fitted")),
                color = 'red') +
      theme_minimal() +
      scale_x_continuous(limits = c(min(time_points), x_max + x_extension)) +
      labs(x = paste0("Time ", time_unit_label), y = "Value")

    matched_row <- titles %>%
      filter(!!sym("FeatureID") == hit_index)

    title <- as.character(matched_row$feature_name)
    
    if (nchar(title) > 30) {
      title_befor <- title
      title <- substr(title, 1, 30)
      message(paste("The feature ID", title_befor, "is > 30 characters.",
                    "Truncating it to 30 chars:", title))
      
    }
    
    if (is.na(title)) {
      title <- paste("feature:", hit_index)
    }

    p <- p + labs(title = title,
                  x = paste0("Time ", time_unit_label), y = "Value") +
      theme(plot.title = element_text(size = 6),
            axis.title.x = element_text(size = 8),
            axis.title.y = element_text(size = 8)) +
      annotate("text", x = x_max + (x_extension / 2), y =
                 max(fitted_values, na.rm = TRUE),
               label = "",
               hjust = 0.5, vjust = 1, size = 3.5, angle = 0, color = "black")

    plot_list[[length(plot_list) + 1]] <- p
  }

  ## Generate the combined plot ------------------------------------------------
  if(length(plot_list) > 0) {
    num_plots <- length(plot_list)
    ncol <- 3
    nrows <- ceiling(num_plots / ncol)

    composite_plot <- patchwork::wrap_plots(plot_list, ncol = 3) +
      patchwork::plot_annotation(title = main_title,
                                 theme = theme(plot.title =
                                                 element_text(hjust = 0.5,
                                                              size = 14)))
    return(list(composite_plot = composite_plot, nrows = nrows))
  } else {
    stop("plot_list in function plot_splines splinetime package has length 0!")
  }
}


#' Build Cluster Hits Report
#'
#' @description
#' Generates an HTML report for clustered hits, including plots and
#' spline parameter details, with a table of contents.
#'
#' @param header_section A character string containing the HTML header section.
#' @param plots A list of ggplot2 plot objects.
#' @param plots_sizes A list of integers specifying the size of each plot.
#' @param level_headers_info A list of header information for each level.
#' @param spline_params A list of spline parameters.
#' @param mode A character string specifying the mode
#'            ('isolated' or 'integrated').
#' @param output_file_path A character string specifying the path to save the
#'                         HTML report.
#'
#' @return No return value, called for side effects.
#'
#' @seealso
#' \code{\link{plot2base64}}, \code{\link{create_progress_bar}}
#'
build_cluster_hits_report <- function(header_section,
                                      plots,
                                      plots_sizes,
                                      level_headers_info,
                                      spline_params,
                                      mode,
                                      output_file_path) {

  html_content <- paste(header_section, "<!--TOC-->", sep = "\n")
  
  toc <- create_toc()
  
  styles <- define_html_styles()
  section_header_style <- styles$section_header_style
  toc_style <- styles$toc_style

  current_header_index <- 1
  j <- 0
  level_headers_info <- Filter(Negate(is.null), level_headers_info)

  
  pb <- create_progress_bar(plots)
  bonus_index <- -1
  
  # Generate the sections and plots
  for (index in seq_along(plots)) {

    if (current_header_index <= length(level_headers_info)) {
      header_info <- level_headers_info[[current_header_index]]
      nr_hits <- header_info$nr_hits

      # means jump to next level
      if (any(class(plots[[index]]) == "character")) {
        
        # So that below the subsection headers are added for ALL levels
        bonus_index <- bonus_index + index
        
        section_header <- sprintf("<h2 style='%s' id='section%d'>%s</h2>",
                                  section_header_style,
                                  index,
                                  header_info$header_name)

        html_content <- paste(html_content, section_header,
                                    sep = "\n")

        if (mode == "integrated") {
          j <- 1
        } else {      # mode == "isolated" or mode == NA
          j <- j + 1
        }

        spline_params_info <-
          get_spline_params_info(spline_params = spline_params,
                                 j = j)

        html_content <- paste(html_content, spline_params_info,
                                    sep = "\n")

        hits_info <- sprintf(
          paste0(
            "<p style='text-align: center; font-size: 30px;'>",
            "Number of hits: %d</p>"
          ),
          nr_hits
        )

        html_content <- paste(html_content, hits_info, sep = "\n")

        toc_entry <- sprintf("<li style='%s'><a href='#section%d'>%s</a></li>",
                             toc_style, index, header_info[[1]])
        toc <- paste(toc, toc_entry, sep = "\n")

        current_header_index <- current_header_index + 1

        pb$tick()
        next
      }
    }
    
    if (index == 2 + bonus_index ||
        index == 5 + bonus_index ||
        index == 6 + bonus_index) {
      
      if (index == 2 + bonus_index) {
        
        adjusted_index <- 2
        
      } else if (index == 5 + bonus_index) {
        
        adjusted_index <- 5
        
      } else {     # index == 6 + bonus_index
        
        adjusted_index <- 6
      }
      
      header <- switch(
        as.character(adjusted_index),
        "2" = paste(
          "<h2 id='section2' style='text-align: center; font-size: 3.5em;'>",
          "Overall Clustering</h2>"
        ),
        "5" = paste(
          "<h2 id='section5' style='text-align: center; font-size: 3.5em;'>",
          "Z-Score of log2 Value Heatmap</h2>"
        ),
        "6" = paste(
          "<h2 id='section6' style='text-align: center; font-size: 3.5em;'>",
          "Individual Features Splines</h2>"
        )
      )
      
      html_content <- paste(html_content, header, sep = "\n")
      
      header_text <- switch(
        as.character(adjusted_index),
        "2" = "Overall Clustering",
        "5" = "Z-Score of log2 Value Heatmap",
        "6" = "Individual Features Splines"
      )
      
      toc_entry <- sprintf(
        "<li style='margin-left: 30px; %s'><a href='#section%s'>%s</a></li>",
        "font-size: 30px;", adjusted_index, header_text
      )
      
      toc <- paste(toc, toc_entry, sep = "\n")
    }
    
    html_content <- process_plots(plots = plots,
                                  plots_sizes = plots_sizes,
                                  index = index,
                                  html_content = html_content)
    
    pb$tick()
  }

  # Close the Table of Contents
  toc <- paste(toc, "</ul></div>", sep="\n")

  # Insert the Table of Contents at the placeholder
  html_content <- gsub("<!--TOC-->", toc, html_content)

  # Append the final closing tags for the HTML body and document
  html_content <- paste(html_content, "</body></html>", sep = "\n")

  # Ensure the directory exists
  dir_path <- dirname(output_file_path)
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE)
  }

  # Write the HTML content to file
  writeLines(html_content, output_file_path)
}


# Level 3 internal functions ---------------------------------------------------


#' Calculate Curve Values Based on Top Table Filter
#'
#' @description This function filters entries from a given top table based on
#' an adjusted p-value threshold,
#' performs spline interpolation using specified degrees of freedom, and
#' calculates curve values
#' for the selected entries at predefined time points. The function is
#' internal and not exported.
#'
#' @param top_table A data frame containing data with a column for adjusted
#' p-values and
#'                  expression averages which indicate the number of degrees
#'                  of freedom.
#' @param level The specific level of the condition to filter on in the
#' metadata.
#' @param meta Metadata containing time points and conditions.
#' @param condition The name of the condition column in the metadata to filter
#' on.
#' @param spline_params A list of spline parameters for the analysis.
#' @param mode A character string specifying the mode
#' ('isolated' or 'integrated').
#'
#' @return A list containing two elements: `curve_values`, a data frame of
#' curve values for each filtered entry, and `smooth_timepoints`, the time
#' points at which curves were evaluated.
#'
#' @importFrom dplyr select all_of
#' @importFrom splines ns
#'
get_curve_values <- function(top_table,
                             level,
                             meta,
                             condition,
                             spline_params,
                             mode) {

  subset_meta <- meta[meta[[condition]] == level, ]

  if (mode == "isolated") {
    level_index <- match(level, unique(meta[[condition]]))
  }
  else if (mode == "integrated") {
    level_index <- 1   # Different spline params not supported for this mode
  }

  smooth_timepoints <- seq(subset_meta$Time[1],
                           subset_meta$Time[length(subset_meta$Time)],
                           length.out = 100)

  args <- list(x = smooth_timepoints, intercept = FALSE)

  if (!is.null(spline_params$dof)) {
    args$df <- spline_params$dof[level_index]
  } else {
    args$knots <- spline_params$knots[[level_index]]
  }

  if (!is.null(spline_params$bknots)) {
    args$Boundary.knots <- spline_params$bknots[[level_index]]
  }


  if (spline_params$spline_type[level_index] == "b") {
    args$degree <- spline_params$degree[level_index]
    X <- do.call(splines::bs, args)
  } else {                                          # natural cubic splines
    X <- do.call(splines::ns, args)
  }

  DoF <- which(names(top_table) == "AveExpr") - 1

  columns_to_select <- 1:DoF

  splineCoeffs <- top_table %>%
    dplyr::select(all_of(1:DoF)) %>%
    as.matrix()

  curve_values <- matrix(nrow = nrow(splineCoeffs),
                         ncol = length(smooth_timepoints))

  for(i in 1:nrow(splineCoeffs)) {
    current_coeffs <- matrix(splineCoeffs[i, ], ncol = ncol(splineCoeffs),
                             byrow = TRUE)

    curve_values[i, ] <- current_coeffs %*% t(X)
  }

  curve_values <- as.data.frame(curve_values)
  rownames(curve_values) <- rownames(splineCoeffs)
  list(curve_values = curve_values,
       smooth_timepoints = smooth_timepoints,
       X = X)
}


#' Normalize Curve Values
#'
#' @description This function normalizes each row in a data frame or matrix
#' of curve values.
#' Normalization is performed so that each row's values range from 0
#' (corresponding to the
#' minimum value of the row) to 1
#' (corresponding to the maximum value of the row).
#'
#' @param curve_values A data frame or matrix of curve values where each row
#' represents
#'        a curve and each column a time point.
#' @return A data frame or matrix with the same dimensions as the input, where
#'  each row
#'         has been normalized.
#'
normalize_curves <- function(curve_values) {

  normalized_curves <- apply(curve_values, 1, function(row) {
    (row - min(row)) / (max(row) - min(row))
  })

  normalized_curves <- t(normalized_curves)
  curve_values[,] <- normalized_curves
  curve_values
}


#' Hierarchical Clustering of Curve Values
#'
#' @description Performs hierarchical clustering on given curve values.
#' It can automatically
#' determine the optimal number of clusters using silhouette analysis or use a
#' specified number. The function adjusts the provided top_table with cluster
#' assignments.
#'
#' @param curve_values A matrix or data frame of curve values to cluster.
#' @param k The number of clusters to use or "auto" to automatically determine
#'          the optimal number using silhouette width analysis.
#' @param smooth_timepoints Numeric vector of time points corresponding to
#'                          columns in curve_values.
#' @param top_table Data frame to be updated with cluster assignments.
#' @return A list containing clustering results and the modified top_table.
#'
#' @importFrom stats dist hclust cutree
#' @importFrom cluster silhouette
#'
hierarchical_clustering <- function(curve_values,
                                    k,
                                    smooth_timepoints,
                                    top_table) {

  distance_matrix <- stats::dist(curve_values, method = "euclidean")
  hc <- stats::hclust(distance_matrix, method = "complete")

  if (is.character(k) && k == "auto") {
    # Calculate silhouette width for a range of clusters
    max_clusters <- 8
    sil_widths <- numeric(max_clusters - 1)
    for (i in 2:max_clusters) {
      temp_clusters <- stats::cutree(hc, k = i)
      silhouette_score <-
        mean(cluster::silhouette(temp_clusters, distance_matrix)[, "sil_width"])

      adjusted_score <- silhouette_score + (0.02 * log(i)) # scaling factor
      sil_widths[i - 1] <- adjusted_score
    }

    # Find the index of the maximum adjusted silhouette score
    best_k_index <- which.max(sil_widths)
    k <- best_k_index + 1  # because index shift due to starting at 2 clusters

    cluster_assignments <- stats::cutree(hc, k = k)
  } else if (is.numeric(k)) {
    cluster_assignments <- stats::cutree(hc, k = k)
  }

  clustered_hits <- data.frame(cluster = cluster_assignments)
  # top_table_hits <- dplyr::filter(top_table, top_table[["adj.P.Val"]] < 0.05)
  clustered_hits$feature <- top_table$feature_index
  clustered_hits <- clustered_hits[, c("feature", "cluster")]

  colnames(curve_values) <- smooth_timepoints
  curve_values$cluster <- cluster_assignments

  top_table$cluster <- NA
  top_table$cluster[1:nrow(clustered_hits)] <-
    as.integer(clustered_hits$cluster)

  group_clustering <- list(clustered_hits = clustered_hits,
                           hc = hc,
                           curve_values = curve_values,
                           top_table = top_table,
                           clusters = k)
}


#' Get Spline Parameters Info
#'
#' @description
#' This function retrieves the spline parameters information for a given index.
#' It ensures the spline parameters are valid and constructs an HTML string
#' describing the spline parameters.
#'
#' @param spline_params A list containing the spline parameters. The list should
#'                      include elements: `spline_type`, `degree`, `dof`,
#'                      `knots`, and `bknots`.
#' @param j An integer specifying the index of the spline parameters to
#' retrieve.
#'
#' @details
#' The function checks if the spline parameters are not `NULL` and have a length
#' greater than or equal to the specified index `j`. If a parameter is
#' invalid or
#' missing, it sets the parameter to `NA`. It then constructs an HTML string
#' describing the spline parameters, including spline type, degree, degrees of
#' freedom (DoF), knots, and boundary knots.
#'
#' @return A character string containing HTML-formatted information about the
#'         spline parameters at the specified index.
#'
get_spline_params_info <- function(spline_params,
                                   j) {

  if (!is.null(spline_params$spline_type) &&
      length(spline_params$spline_type) >= j) {
    spline_params$spline_type[j] <- spline_params$spline_type[j]
  } else {
    spline_params$spline_type[j] <- NA
  }

  if (!is.null(spline_params$degree) &&
      length(spline_params$degree) >= j) {
    spline_params$degree[j] <- spline_params$degree[j]
  } else {
    spline_params$degree[j] <- NA
  }

  if (!is.null(spline_params$dof) &&
      length(spline_params$dof) >= j) {
    spline_params$dof[j] <- spline_params$dof[j]
  } else {
    spline_params$dof[j] <- NA
  }

  if (!is.null(spline_params$knots) &&
      length(spline_params$knots) >= j) {
    spline_params$knots[j] <- spline_params$knots[j]
  } else {
    spline_params$knots[j] <- NA
  }

  if (!is.null(spline_params$bknots) &&
      length(spline_params$bknots) >= j) {
    spline_params$bknots[j] <- spline_params$bknots[j]
  } else {
    spline_params$bknots[j] <- NA
  }

  if (spline_params$spline_type[j] == "b") {
    spline_params_info <-
      sprintf("<p style='text-align: center; font-size: 30px;'>
                    <span style='color: blue;'>Spline-type:</span> B-spline<br>
                    <span style='color: blue;'>Degree:</span> %s<br>
                    <span style='color: blue;'>DoF:</span> %s<br>
                    <span style='color: blue;'>Knots:</span> %s<br>
                    <span style='color: blue;'>Boundary-knots:</span> %s</p>",
              spline_params$degree[j], spline_params$dof[j],
              spline_params$knots[j], spline_params$bknots[j])
  } else {    # == "n"
    spline_params_info <-
      sprintf("<p style='text-align: center; font-size: 30px;'>
                    <span style='color: blue;'>Spline-type:</span> Natural cubic
                    spline<br>
                    <span style='color: blue;'>DoF:</span> %s<br>
                    <span style='color: blue;'>Knots:</span> %s<br>
                    <span style='color: blue;'>Boundary-knots:</span> %s</p>",
              spline_params$dof[j], spline_params$knots[j],
              spline_params$bknots[j])

  }
  return(spline_params_info)
}
