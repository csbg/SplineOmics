---
title: "demo"
author: "Thomas Rauter"
date: "15 July, 2024"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# About this tutorial

This tutorial intends to showcase and explain the capabilities of the
SplineOmics package by walking through a real and complete example, from
start to the end. The example is a time-series proteomics experiment, in
which CHO cells were cultivated in three bioreactors (three biological
replicates). Both in the exponential and stationary growth phase,
samples were taken from each reactor in triplicates at defined
timepoints relative to a feeding of the cells (60 min before feeding,
and 15, 60, 90, 120, and 240 min after). The goal of this analysis is to
find out which of the 7162 cellular proteins show a significant change
over time after the CHO cells were fed (= impact of the feeding).
Further, the hits (proteins with a significant change over time) are
clustered based on their temporal pattern, and a gene set enrichment
analysis is performed with each cluster to see if there are processes
which are up- or downregulated over time after the feeding.

# Load the packages

```{r Load the required packages}
library(SplineOmics)   # Functions are marked with SplineOmics::

# Additional packages needed to prepare SplineOmics function inputs
library(readxl)
library(here)
library(readr)
library(dplyr)
```

# Load the files

In this example, the data.xlsx file contains the numeric values (the
intensities) and also the feature descriptions, such as gene and protein
name (= annotation part)

The file meta.xlsx contains the meta information, which are the
descriptions of the columns of the numeric values of data.

(These example files are part of the package and don't have to be
present on your system. For your analysis, create filepath for example with the
here library instead of system.file)

```{r Load the files}
data_excel <- readxl::read_excel(
    system.file(
      "extdata",
      "proteomics_data.xlsx",
      package = "SplineOmics"
      )
    )

meta <- readxl::read_excel(
  system.file(
    "extdata",
    "proteomics_meta.xlsx",
    package = "SplineOmics"
    )
  )

# Extract the annotation part from the dataframe.
first_na_col <- which(is.na(data_excel[1,]))[1]
annotation <- data_excel |>
  dplyr::select((first_na_col + 1):ncol(data_excel)) |>
  dplyr::slice(-c(1:3))
```

# Bring the inputs into the standardized (required) format

Since data_excel is not in the format that is required by the
SplineOmics package, it still needs some processing. This can be with a
few commands in R, but if your file looks like the one here, with the
data matrix field on the left and the annotation info on the right,
separated by one empty column, then the function extract_data() can do
this processing automatically. It identifies this data matrix field, and
puts it into a dataframe. The column headers are made up of all the
infos that are written in the cells above the respective column of this
data matrix field. The rowheaders are increasing numbers if no
annotation columns were specified. In this example, the annotation
columns "First.Protein.Description" and "ID" are specified so that these
are combined and form the rowheaders (feature names). They will be used
to label any plots were a feature is shown individually (such as the
spline plots with the datapoints from an individual feature).

```{r Process the inputs}
data <- SplineOmics::extract_data(
  data_excel,
  c(
    "First.Protein.Description",
    "ID"
    )
  )
```

# Perform EDA (exploratory data analysis)

The first step in analysing data is usually EDA. EDA involves
summarizing the main characteristics of the data, often using plots.
This can involve densitiy distributions, boxplots, PCA, correlation
heatmaps, and more. This process can be carried out by using the package
function explore_data(). The necessary arguments are the data matrix
(data), the meta table (meta), the name of the column that contains the
levels of the experiment (condition) (the levels here are Exponential
and Stationary), and the report_info list, that contains general info
about the analysis. Optional arguments are meta_batch_column and
meta_batch2_column, that allow to specify the column name that contain
batch effect 1 and 2. These columns will be used to run the
removeBatchEffect function of limma to remove the batch effect of the
data for plotting. When at least one batch column is provided like this,
the function will not just generate one EDA HTML report, but two. One
for the uncorrected data, and one for the batch corrected data. These
reports are written either in the current working dir as default
location, or to a location specified with the optional argument
report_dir. The function also returns all plots generated. Lastly, if it
is desired that no report should be generated, the optional argument
report can be set to FALSE.

```{r Define info that is written in all the HTML reports}
report_info <- list(
  omics_data_type = "PTX",
  data_description = "Proteomics data of CHO cells",
  data_collection_date = "February 2024",
  analyst_name = "Thomas Rauter",
  contact_info = "thomas.rauter@plus.ac.at",
  project_name = "DGTX"
  )
```

Because multiple functions of the SplineOmics object take the same inputs, and
because some functions generate "intermediate" output, which is just used by 
subsequent functions in the workflow, the SplineOmics object is used. This can
be seen as a bag where all those arguments are stored, and each function takes
the needed arguments from there and potentially puts something additional in. 

The documentation of each function describes which arguments must be in the 
SplineOmics object when it is passed to the respective function.


```{r Create the SplineOmics object}
splineomics <- SplineOmics::create_splineomics(
  data = data,
  meta = meta,
  annotation = annotation,
  report_info = report_info,
  condition = "Phase",
  meta_batch_column = "Reactor"
)
```

```{r Run the EDA function}
report_dir <- here::here(
  "demo_results",
  "explore_data"
  )

plots <- SplineOmics::explore_data(
  splineomics = splineomics,
  report_dir = report_dir
  )

```

The EDA plots can tell you a range of things. The plots in the HTML
report are grouped into three categories: distribution and variability
analysis, time series analysis, and dimensional reduction and
clustering.

If you look at the correlation heatmaps in the HTML report, you can see
that the samples E12_TP05_Exponential and E10_TP10_Stationary stick out.
Seeing this, you might want to remove them from the data. You can test
out what happens when you do this, along with testing how other
hyperparameter choices influence the results, with the package function
screen_limma_hyperparams().

# Find the best hyperparameters

Before we can run the limma spline analysis, we have to find out which
"hyperparameters" are the best. Hyperparameters in this context are for
example degree of freedom, different versions of the data (outlier
removed vs. not removed), different limma design formulas, etc.
Rationally thinking about which combination of hyperparameters to use is
very challenging. Instead, it is often better to just try out a bunch of
combinations and choose the best. The function
screen_limma_hyperparams() does this for you. For each hyperparameter,
you can just specify all the values that you would like to try, and the
function then runs the limma spline analysis with the combinations that
can be formed with the hyperparameters that you specified. Not every
single combo is generated, but instead there are "inner" and "outer"
hyperparameters, and only for all "outer" hyperparameters, all combos
are generated. The "inner" hyperparameters are the adj. p-value
thresholds and the spline parameters. For example, if you have two
different versions of one dataset (one time the full dataset, and one
time the dataset with some potential outliers removed), these are
considered "outer" hyperparameters in this context. The function would
generate all possible comparisons for the "outer" hyperparameters, which
is just a single comparison. Then, for both versions of the data, every
"inner" hyperparameter combo is generated. Lets say you specified
natural cubic splines for both, with a degree of freedom of either 2 or
3. For the adj. p-value threshold, you specified 0.05 or 0.1. For each
version of data, it would test out all combinations of the spline
parameters and the adj. p-value threshold. In this case, this is DoF =
2, thesh = 0.05; DoF = 3, tresh = 0.05; DoF = 2, tresh = 0.1; DoF = 3,
tresh = 0.1.

```{r Load hyperparameter-screening args}
data1 <- data 
meta1 <- meta

data2 <- data[, !(colnames(data) %in% c(
  "E12_TP05_Exponential", 
  "E10_TP10_Stationary"
  )
  )]

meta2 <- meta[!meta$`Sample.ID` %in% c(
  "E12_TP05_Exponential", 
  "E10_TP10_Stationary"
  ), ]

datas <- list(data1, data2) 
datas_descr <- c(
  "full_data",
  "outliers_removed"
  ) 

metas <- list(
  meta1,
  meta2
  ) 

designs <- c(
  "~ 1 + Phase*X + Reactor",
  "~ 1 + X + Reactor"
  ) 

condition <- "Phase" 

meta_batch_column = "Reactor" 

pthresholds <- c(
  0.05,
  0.1
  )

# Every row a combo to test.
spline_test_configs <- data.frame(
  spline_type = c("n", "n", "n", "n"),
  degree = c(NA, NA, NA, NA),
  dof = c(2L, 3L, 4L, 5L),
  knots = I(list(c(NA), c(NA), c(NA), c(NA))),                                                     bknots = I(list(c(NA), c(NA), c(NA), c(NA)))
  )
```

```{r Perform hyperparameter-screening}
report_dir <- here::here(
  "demo_results",
  "hyperparams_screen_reports"
  ) 

SplineOmics::screen_limma_hyperparams(
  splineomics,
  datas,
  datas_descr,
  metas,
  designs,
  spline_test_configs,
  report_dir,
  pthresholds,
  )
```

# Run limma spline analysis

Once we identified the hyperparameters, that are likely the best ones,
we can run the limma spline analysis with them and get the results.

```{r Update the SplineOmics object}
splineomics <- SplineOmics::update_splineomics(
  splineomics = splineomics,
  data = data2,
  meta = meta2,
  design = "~ 1 + Phase*X + Reactor",
  spline_params = list(
    spline_type = c("n"),   
    dof = c(2L)
    )
)
```

```{r Run the limma spline analysis}

# Run the limma spline analysis
splineomics <- SplineOmics::run_limma_splines(
  splineomics
  )
```

The output of the function run_limma_splines() is a named list, where
each element is a specific "category" of results. Each of those elements
is a list, containing as elements the respective limma topTables, either
for each level or each comparison between two levels.

The element "time_effect" is a list, where each element is the topTable
where the p-value for each feature for the respective level are
reported.

The element "avrg_diff_conditions" is a list that contains as elements
the topTables, that represent the comparison of the average differences
of the levels.

The element "interaction_condition_time" is a list that contains as
elements the topTables, that represent the interaction between the
levels (which includes both time and the average differences)

# Build limma report

The topTables of all three categories can be used to generate p-value
histograms an volcano plots.

```{r Build limma report}
report_dir <- here::here(
  "demo_results",
  "create_limma_reports"
  )

plots <- SplineOmics::create_limma_report(
  splineomics,
  report_dir = report_dir
  )
```

# Cluster the hits (significant features)

After we obtained the limma spline results, we can cluster the hits
based on their temporal pattern (their spline shape). We define what a
hit is by setting an adj. p-value threshold for every level. Then,
hierarchical clustering is used to place every hit in one of as many
clusters as we have specified for that specific level.

```{r Cluster the hits}
adj_pthresholds <- c(
  0.05,
  0.05
  )

clusters <- list(
  6L,
  3L
  )

report_dir <- here::here(
  "demo_results",
  "clustering_reports"
  )

plot_info = list(
  y_axis_label = "log2 intensity",
  time_unit = "min",
  treatment_labels = c("Feeding"),
  treatment_timepoints = c(0)
)

gene_column_name <- "Genes"
genes <- data_excel[[gene_column_name]][4:nrow(data_excel)]

clustering_results <- SplineOmics::cluster_hits(
  splineomics = splineomics,
  analysis_type = "time_effect",
  adj_pthresholds = adj_pthresholds,
  clusters = clusters,
  genes = genes,
  plot_info = plot_info,
  report_dir = report_dir,
  )
```

# Perform gene set enrichment analysis (GSEA)

To each clustered hit, the respective gene can be assigned and GSEA
performed. For this, the Enrichr databases of choice have to be
downloaded:

```{r Define which Enrichr databases to download}
gene_set_lib <- c(
  "WikiPathways_2019_Human",
  "NCI-Nature_2016",
  "TRRUST_Transcription_Factors_2019",
  "MSigDB_Hallmark_2020",
  "GO_Cellular_Component_2018",
  "CORUM",
  "KEGG_2019_Human",
  "TRANSFAC_and_JASPAR_PWMs",
  "ENCODE_and_ChEA_Consensus_TFs_from_ChIP-X",
  "GO_Biological_Process_2018",
  "GO_Molecular_Function_2018",
  "Human_Gene_Atlas"
  )
```

```{r Download the Enrichr databases}
output_dir  <- here::here(
  "demo_results",
  "downloaded_databases"
  )

SplineOmics::download_enrichr_databases(
  gene_set_lib = gene_set_lib,
  output_dir = output_dir
  )
```

To run GSEA, a genes vector has to be created, containing all the
underlying genes of the features. The downloaded database file has to be
loaded as a dataframe. Further, optionally, the clusterProfiler
parameters and the report dir can be specified. The function
create_gsea_report() runs GSEA using clusterProfiler, generates an HTML
report and returns the GSEA dotplots in R.

```{r Run GSEA}
# Get gene vector. 
# For your analysis, this code needs to be customized based on the format.
gene_column_name <- "Genes"
genes <- annotation[[gene_column_name]][1:nrow(annotation)]
genes <- sub(" .*", "", genes)
genes <- sub(";.*", "", genes)
genes <- sub("_.*", "", genes)
genes <- sub("-.*", "", genes)

# The file has a timestamp, but this code takes it irrespective of it.
downloaded_dbs_filepath <- list.files(
  path = output_dir,
  pattern = "\\.tsv$",
  full.names = TRUE
  )[1]

databases <- readr::read_tsv(
  downloaded_dbs_filepath,
  col_types = readr::cols()
  )

clusterProfiler_params <- list(
  adj_p_value = 0.05,
  pAdjustMethod = "BH",
  minGSSize = 10,
  maxGSSize = 500,
  qvalueCutoff = 0.2
  )

report_dir <- here::here(
  "demo_results",
  "gsea_reports"
  )

result <- SplineOmics::create_gsea_report(
  levels_clustered_hits = clustering_results$clustered_hits_levels,
  genes = genes,
  databases = databases,
  params = clusterProfiler_params,
  report_info = report_info,
  report_dir = report_dir
  )
```

In the output HTML, every row in the dotplots is a term from a specific 
database, and the columns are the respective clusters. The color scale contains the info about the odds ratio and the size the -log10 adj. p-value. Only terms
that have more than 2 genes as support are included in the plot.
Further, for each cluster, just maximally 5 terms are shown (the terms
with the highest odds ratios). Note that when for example cluster 1
already has 5 terms, and cluster 2 does not, and gets a term which was
also found for cluster 1, than this term would be included as the sixth
term for cluster 1, so this is a way the maximum of 5 can be exceeded.
