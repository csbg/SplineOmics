---
title: "get-started"
author: "Thomas Rauter"
date: "10 June, 2024"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{get-started}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# About this tutorial

This tutorial intends to showcase and explain the capabilities of the
**SplineOmics** package by walking through a real and complete example,
from start to finish.

### Example Overview

The example involves a **time-series proteomics experiment**, where CHO
(chinese hamster ovary) cells were cultivated in three bioreactors
(three biological replicates). The experiment includes the following
setup:

-   Samples were taken both during the **exponential** and **stationary
    growth phases**.
-   Samples were collected in triplicates from each reactor at defined
    timepoints relative to cell feeding:
    -   60 minutes before feeding
    -   15, 60, 90, 120, and 240 minutes after feeding

### Analysis Goals

The main goals of this analysis are:

-   **Identify proteins with significant temporal changes**: Out of 7162
    cellular proteins, the objective is to detect which proteins show a
    significant change over time after the CHO cells were fed (i.e., the
    impact of the feeding).
-   **Cluster hits based on temporal patterns**: The proteins (hits)
    with significant temporal changes will be clustered according to
    their time-based patterns.
-   **Perform gene set enrichment analysis**: For each cluster, a gene
    set enrichment analysis will be performed to determine if specific
    biological processes are up- or downregulated after feeding.

# Load the packages

```{r setup}
library(SplineOmics)
library(readxl)
```

# Load the files

In this example, the data.xlsx file contains the numeric values (the
intensities) and also the feature descriptions, such as gene and protein
name (= annotation part)

The file meta.xlsx contains the meta information, which are the
descriptions of the columns of the numeric values of data.

(These example files are part of the package and don't have to be
present on your system).

Please note that this dataset is an actual experimental dataset, but the
annotation information, such as gene names, has been removed since it is
not yet published. Instead, the dataset includes randomly generated gene
symbols and gene names corresponding to Cricetulus griseus (Chinese
Hamster) for each row. This is intended to demonstrate the functionality
of the package.

```{r load the files}

data_excel <- readRDS(system.file(
  "extdata",
  "proteomics_data.rds",
  package = "SplineOmics"
  ))


meta <- read_excel(
  system.file(
    "extdata",
    "proteomics_meta.xlsx",
    package = "SplineOmics"
    )
  )

# Extract the annotation part from the dataframe.
first_na_col <- which(is.na(data_excel[1,]))[1]
annotation <- data_excel |>
  dplyr::select((first_na_col + 1):ncol(data_excel)) |>
  dplyr::slice(-c(1:3))

print(data_excel)
print(annotation)
print(meta)
```

## Bring the Inputs into the Standardized Format

Since `data_excel` is not in the format required by the **SplineOmics**
package, it needs some processing. This can be done with a few commands
in R, but if your file has a specific structure, the function
`extract_data()` can handle this automatically.

### File Structure Requirements

If your file looks like the one used here, where:

-   The **data matrix field** is on the left
-   The **annotation info** is on the right
-   These fields are separated by one empty column

Then, `extract_data()` can:

-   **Identify the data matrix field** and convert it into a dataframe.
-   **Create column headers** from the information written in the cells
    above the respective columns of the data matrix field.
-   **Assign rowheaders**:
    -   If no annotation columns are specified, rowheaders will be
        increasing numbers.
    -   If annotation columns are specified (like
        `"First.Protein.Description"` and `"ID"` in this example), these
        will be combined to form the rowheaders (feature names).

### Usage in Plotting

The generated rowheaders will be used to label any plots where a feature
is shown individually, such as:

-   **Spline plots** with the datapoints from an individual feature.

```{r process inputs, eval = TRUE}
data <- extract_data(
  data = data_excel,
  feature_name_columns = c("Gene_name"),
  user_prompt = FALSE
  )
```

# Perform EDA (exploratory data analysis)

The first step in analyzing data is typically **Exploratory Data
Analysis (EDA)**. EDA involves summarizing the main characteristics of
the data, often through visualizations.

### Common EDA Plots

Some common types of EDA plots include:

-   **Density distributions**
-   **Boxplots**
-   **PCA (Principal Component Analysis)**
-   **Correlation heatmaps**

### Using `explore_data()` for EDA

The **SplineOmics** package provides the function `explore_data()` to
perform EDA. This function requires the following arguments:

-   **data**: The data matrix.
-   **meta**: The metadata table.
-   **condition**: The name of the column in the metadata that contains
    the levels of the experiment (e.g., "Exponential" and "Stationary").
-   **report_info**: A list that contains general information about the
    analysis.

### Optional Arguments

In addition to the required arguments, `explore_data()` offers several
optional arguments:

-   **meta_batch_column**: The name of the column that contains the
    first batch effect.

-   **meta_batch2_column**: The name of the column that contains the
    second batch effect.

    If at least one batch column is provided, the function will:

    -   Use the `removeBatchEffect()` function from **limma** to remove
        the batch effect from the data before plotting.
    -   Generate two EDA HTML reports: one for the **uncorrected data**
        and one for the **batch-corrected data**.

### Output and Report Options

-   By default, the reports are saved in the **current working
    directory**, but this location can be changed using the `report_dir`
    argument.
-   The function also **returns all plots** generated during the
    analysis.
-   If you do not want a report to be generated, you can set the
    `report` argument to `FALSE`.

```{r Load EDA arguments, eval = TRUE}
report_info <- list(
  omics_data_type = "PTX",
  data_description = "Proteomics data of CHO cells",
  data_collection_date = "February 2024",
  analyst_name = "Thomas Rauter",
  contact_info = "thomas.rauter@plus.ac.at",
  project_name = "DGTX"
  )

report_dir <- here::here(
  "results",
  "explore_data"
  )
```

```{r Create the SplineOmics object, eval = TRUE}
splineomics <- create_splineomics(
  data = data,
  meta = meta,
  annotation = annotation,
  report_info = report_info,
  condition = "Phase",
  meta_batch_column = "Reactor"
)
```

```{r Run EDA function, eval = FALSE}
plots <- explore_data(
  splineomics = splineomics,
  report_dir = report_dir
  )

```

## Finding the Best Hyperparameters

Before running the **limma spline analysis**, it is important to find
the best "hyperparameters". In this context, hyperparameters include:

-   **Degree of freedom (DoF)**
-   **Different versions of the data** (e.g., outlier removed vs. not
    removed)
-   **Different limma design formulas**

### Challenge of Hyperparameter Selection

Rationally determining the best combination of hyperparameters can be
very challenging. Instead of manually selecting combinations, it is
often more effective to try out multiple combinations and choose the
best-performing one.

### Using `screen_limma_hyperparams()`

The function `screen_limma_hyperparams()` automates the process of
testing different combinations of hyperparameters. Here's how it works:

-   **Specify values**: For each hyperparameter, you can specify all the
    values you want to test.
-   **Run combinations**: The function runs the **limma spline
    analysis** with combinations formed from the hyperparameters you've
    provided.

### Inner vs. Outer Hyperparameters

Not every possible combination is generated. Instead, there are
**inner** and **outer** hyperparameters:

-   **Outer hyperparameters**: These include things like **different
    versions of the dataset** (e.g., full dataset vs. dataset with
    outliers removed).
    -   All possible combinations of outer hyperparameters are
        generated.
-   **Inner hyperparameters**: These include **adjusted p-value
    thresholds** and **spline parameters** (e.g., degree of freedom).
    -   For each version of the data (outer hyperparameter), all
        combinations of inner hyperparameters are tested.

### Example

For example, if you have two versions of a dataset (one full dataset,
and one with some outliers removed), these versions are considered outer
hyperparameters. The function will generate comparisons for both
versions of the dataset.

For each version, let's say you specify the following inner
hyperparameters:

-   **Spline parameters**: Natural cubic splines with a degree of
    freedom of either 2 or 3.
-   **Adjusted p-value threshold**: 0.05 or 0.1.

The function will generate and test all combinations of the spline
parameters and p-value thresholds for both versions of the data:

-   **DoF = 2, threshold = 0.05**
-   **DoF = 3, threshold = 0.05**
-   **DoF = 2, threshold = 0.1**
-   **DoF = 3, threshold = 0.1**

This allows you to systematically explore different combinations and
select the optimal hyperparameters for your analysis.

```{r Load hyperparameter-screening args, eval = TRUE}
data1 <- data 
meta1 <- meta

data2 <- data[, !(colnames(data) %in% c(
  "E12_TP05_Exponential", 
  "E10_TP10_Stationary"
  )
  )]
meta2 <- meta[!meta$`Sample.ID` %in% c(
  "E12_TP05_Exponential", 
  "E10_TP10_Stationary"
  ), ]

datas <- list(data1, data2) 
datas_descr <- c(
  "full_data",
  "outliers_removed"
  ) 

metas <- list(meta1, meta2) 
designs <- c(
  "~ 1 + Phase*X + Reactor",
  "~ 1 + X + Reactor"
  ) 
condition <- "Phase" 
report_dir <- here::here(
  "results",
  "hyperparams_screen_reports"
  ) 
meta_batch_column = "Reactor" 
pthresholds <- c(
  0.05,
  0.1
  )

# Create a dataframe with combinations of spline parameters to test
# (every row a combo to test)
spline_test_configs <- data.frame(
   # 'n' stands for natural cubic splines, b for B-splines.
  spline_type = c("n", "n", "b", "b"),  
  # Degree is not applicable (NA) for natural splines.
  degree = c(NA, NA, 2L, 4L),           
  # Degrees of freedom (DoF) to test.
  # Higher dof means spline can fit more complex patterns.
  dof = c(2L, 3L, 3L, 4L)         
)

print(spline_test_configs)
```

```{r Perform hyperparameter-screening, eval = FALSE}
screen_limma_hyperparams(
  splineomics,
  datas,
  datas_descr,
  metas,
  designs,
  spline_test_configs,
  report_dir,
  pthresholds,
  )

```

You can view an example report [here](https://github.com/csbg/SplineOmics_html_reports/raw/97b73e1cf1353df11a9035f576b98167699cf03c/Data_1_Design_1_vs_Data_1_Design_2_PTX_19_09_2024-13_44_10.html)

This report contains the results for the comparison of the "outer" hyperparameters
data 1 and design (formula) 1 against data 1 and design 2. For both of those, all combinations of the "inner" hyperparameters are generated (every possible combination of all specified adj. p-value thresholds and spline configs).

The encoding of this is [here](https://github.com/csbg/SplineOmics_html_reports/blob/97b73e1cf1353df11a9035f576b98167699cf03c/hyperparams_screen_meta_table_19_09_2024-13_44_10.html)
(This is part of the output of the screen_limma_hyperparams function).

# Run limma spline analysis

Once we identified the hyperparameters that are likely the best ones, we
can run the limma spline analysis with them and get the results.

Lets just assume for now that the new parameters, with which the
SplineOmics object is updated, are the best for this analysis. The
choice depends on the analysis. For example, for this analysis, natural
cubic splines (n) with a dof of two seemed to fit the data best (not
overfitting, but also not underfitting), which was the reason those
spline parameters were chosen.

```{r Update the SplineOmics object, eval = TRUE}
splineomics <- update_splineomics(
  splineomics = splineomics,
  design = "~ 1 + Phase*X + Reactor",
  data = data2, 
  meta = meta2,  
  spline_params = list(
    spline_type = c("n"),   
    dof = c(2L)
    )
)

```

```{r limma spline analysis, eval = TRUE}

# Run the limma spline analysis
splineomics <- run_limma_splines(
  splineomics
  )
```

The output of the function run_limma_splines() is a named list, where
each element is a specific "category" of results. Refer to [this
document](../inst/descriptions/limma_result_categories.pdf) for an
explanation of the different result categories. Each of those elements
is a list, containing as elements the respective limma topTables, either
for each level or each comparison between two levels.

The element "time_effect" is a list, where each element is the topTable
where the p-value for each feature for the respective level are
reported.

The element "avrg_diff_conditions" is a list that contains as elements
the topTables, that represent the comparison of the average differences
of the levels.

The element "interaction_condition_time" is a list that contains as
elements the topTables, that represent the interaction between the
levels (which includes both time and the average differences)

# Build limma report

The topTables of all three categories can be used to generate p-value
histograms an volcano plots.

```{r build limma report, eval = FALSE}
report_dir <- here::here(
  "results",
  "create_limma_reports"
  )

plots <- create_limma_report(
  splineomics,
  report_dir = report_dir
  )
```

You can view the generated analysis report of the create_limma_report
function [here](https://github.com/csbg/SplineOmics_html_reports/raw/97b73e1cf1353df11a9035f576b98167699cf03c/create_limma_report_PTX_19_09_2024-13_47_02.html).

# Cluster the hits (significant features)

After we obtained the limma spline results, we can cluster the hits
based on their temporal pattern (their spline shape). We define what a
hit is by setting an adj. p-value threshold for every level. Then,
hierarchical clustering is used to place every hit in one of as many
clusters as we have specified for that specific level.

```{r cluster the hits, eval = FALSE}
adj_pthresholds <- c(
  0.05,
  0.05
  )

clusters <- c(
  6L,
  3L
  )

report_dir <- here::here(
  "results",
  "clustering_reports"
  )

plot_info = list(
  y_axis_label = "log2 intensity",
  time_unit = "min",
  treatment_labels = c("Feeding"),
  treatment_timepoints = c(0)
)

gene_column_name <- "Gene_symbol"
genes <- data_excel[[gene_column_name]][4:nrow(data_excel)]

clustering_results <- cluster_hits(
  splineomics = splineomics,
  analysis_type = "time_effect",
  adj_pthresholds = adj_pthresholds,
  clusters = clusters,
  genes = genes,
  plot_info = plot_info,
  report_dir = report_dir,
  )
```

You can view the generated analysis report of the cluster_hits
function [here](https://github.com/csbg/SplineOmics_html_reports/raw/97b73e1cf1353df11a9035f576b98167699cf03c/report_clustered_hits_PTX_19_09_2024-13_47_08.html).

# Perform gene set enrichment analysis (GSEA)

To each clustered hit, the respective gene can be assigned and GSEA
performed. For this, the Enrichr databases of choice have to be
downloaded:

```{r download Enrichr databases, eval = FALSE}
gene_set_lib <- c(
  "WikiPathways_2019_Human",
  "NCI-Nature_2016",
  "TRRUST_Transcription_Factors_2019",
  "MSigDB_Hallmark_2020",
  "GO_Cellular_Component_2018",
  "CORUM",
  "KEGG_2019_Human",
  "TRANSFAC_and_JASPAR_PWMs",
  "ENCODE_and_ChEA_Consensus_TFs_from_ChIP-X",
  "GO_Biological_Process_2018",
  "GO_Molecular_Function_2018",
  "Human_Gene_Atlas"
  )

download_enrichr_databases(gene_set_lib)
```

Per default the file is placed in the current working directory, which
is the root dir of the R project.

To run GSEA, the downloaded database file has to be
loaded as a dataframe. Further, optionally, the clusterProfiler
parameters and the report dir can be specified. The function
create_gsea_report() runs GSEA using clusterProfiler, generates an HTML
report and returns the GSEA dotplots in R.

```{r run GSEA, eval = FALSE}
downloaded_dbs_filepath <-
  here::here("all_databases_08_04_2024-12_41_50.tsv")

databases <- readr::read_tsv(
  downloaded_dbs_filepath,
  col_types = readr::cols()
  )

clusterProfiler_params <- list(
  adj_p_value = 0.05,
  pAdjustMethod = "BH",
  minGSSize = 10,
  maxGSSize = 500,
  qvalueCutoff = 0.2
  )

report_dir <- here::here(
  "results",
  "gsea_reports"
  )

result <- create_gsea_report(
  levels_clustered_hits = clustering_results$clustered_hits_levels,
  databases = databases,
  params = clusterProfiler_params,
  report_info = report_info,
  report_dir = report_dir
  )
```

You can view the generated analysis report of the cluster_hits
function [here](https://github.com/csbg/SplineOmics_html_reports/raw/97b73e1cf1353df11a9035f576b98167699cf03c/create_gsea_report_PTX_19_09_2024-13_47_33.html).

Every row in the dotplots is a term from a specific database, and the
columns are the respective clusters. The color scale contains the info
about the odds ratio and the size the -log10 adj. p-value. Only terms
that have \> 2 genes as support are included in the plot. Further, for
each cluster, just maximally 5 terms are shown (the terms with the
highest odds ratios). Note that when for example cluster 1 already has 5
terms, and cluster 2 does not, and gets a term which was also found for
cluster 1, than this term would be included as the sixth term for
cluster 1, so this is a way the maximum of 5 can be exceeded.
