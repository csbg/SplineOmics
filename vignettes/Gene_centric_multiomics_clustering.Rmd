---
title: "Gene-centric multiomics clustering"
author: "Thomas Rauter"
date: "19 January, 2026"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Gene-centric multiomics clustering}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

# Gene-centric multiomics clustering

This vignette demonstrates the gene-centric multi-omics clustering
approach implemented in `SplineOmics::cluster_genes_multiomics()` and
shows how to visualize the results using
`SplineOmics::plot_umap_clusters()`.

**Figure 1.** Overview of the gene-centric multi-omics clustering
approach.  
See the figure
[**here**](https://raw.githubusercontent.com/csbg/SplineOmics_html_reports/main/figures/SplineOmics_%20cluster_genes_multiomics_approach.png).

The example below uses a small synthetic dataset with two experimental
conditions and three molecular modalities, including a many-to-one
feature-level modality.

## Load required packages

```{r load libraries, eval = TRUE}
library(SplineOmics)
library(tibble)
library(ggplot2)
```

## 1. Simulate multi-omics time-series data

We simulate expression trajectories for 40 genes measured at 9 time
points. Each gene is assigned to one of five latent temporal patterns
used only for data generation.

```{r Simulate multi-omics time-series data, eval = TRUE}
set.seed(1)
n_genes <- 40
genes <- paste0("gene", seq_len(n_genes))
n_tp <- 9
t <- seq(0, 1, length.out = n_tp)

.add_noise <- function(x, sd = 0.15) {
  x + rnorm(length(x), mean = 0, sd = sd)
}

shapes <- list(
  sin   = sin(2 * pi * t),
  cos   = cos(2 * pi * t),
  up    = 2 * t - 1,
  down  = 1 - 2 * t,
  peak  = exp(-((t - 0.5) / 0.18)^2) * 2 - 1
)

true_k <- 5
gene_group <- sample(seq_len(true_k), n_genes, replace = TRUE)
```


## 1.1 Simulate RNA and protein (one-to-one modalities)

RNA is generated directly from the latent shapes. Protein trajectories
are simulated as lagged and scaled versions of RNA, mimicking delayed
protein dynamics.

```{r Simulate RNA and protein, eval = TRUE}
.simulate_one_to_one <- function(
  genes,
  shapes,
  gene_group,
  noise_sd = 0.18
) {
  n_genes <- length(genes)
  n_tp <- length(shapes[[1]])

  X <- matrix(
    NA_real_,
    nrow = n_genes,
    ncol = n_tp,
    dimnames = list(genes, paste0("tp", seq_len(n_tp)))
  )

  for (i in seq_len(n_genes)) {
    k <- gene_group[i]
    X[i, ] <- .add_noise(shapes[[k]], sd = noise_sd)
  }

  X
}

rna_ctrl <- .simulate_one_to_one(
  genes = genes,
  shapes = shapes,
  gene_group = gene_group,
  noise_sd = 0.16
)

rna_treat <- rna_ctrl
for (i in seq_len(n_genes)) {
  k <- gene_group[i]
  rna_treat[i, ] <-
    .add_noise(shapes[[k]] + 0.15 * t, sd = 0.16)
}

protein_ctrl <- rna_ctrl
protein_treat <- rna_treat
```


## 1.2 Simulate phospho features (many-to-one modality)

For each gene, multiple phospho features are generated. Rows are named
`<gene>_<feature>` to encode the many-to-one mapping.

```{r Simulate phospho features, eval = TRUE}
.simulate_many_to_one <- function(
  genes,
  shapes,
  gene_group,
  min_feat = 1,
  max_feat = 4,
  noise_sd = 0.20
) {
  feat_counts <- sample(
    min_feat:max_feat,
    length(genes),
    replace = TRUE
  )

  feat_ids <- unlist(
    mapply(
      function(g, n) paste0(g, "_p", seq_len(n)),
      genes,
      feat_counts,
      SIMPLIFY = FALSE
    ),
    use.names = FALSE
  )

  n_tp <- length(shapes[[1]])
  X <- matrix(
    NA_real_,
    nrow = length(feat_ids),
    ncol = n_tp,
    dimnames = list(feat_ids, paste0("tp", seq_len(n_tp)))
  )

  idx <- 0L
  for (i in seq_along(genes)) {
    base <- shapes[[gene_group[i]]]
    for (j in seq_len(feat_counts[i])) {
      idx <- idx + 1L
      X[idx, ] <- .add_noise(base, sd = noise_sd)
    }
  }

  X
}

phospho_ctrl <- .simulate_many_to_one(
  genes,
  shapes,
  gene_group
)

phospho_treat <- phospho_ctrl
```

## 2. Assemble inputs for clustering

Each condition is represented as a list of modality matrices. The
`meta` data frame describes modality properties shared across
conditions.

```{r Assemble inputs for clustering, eval = TRUE}
data <- list(
  Ctrl = list(
    rna     = rna_ctrl,
    protein = protein_ctrl,
    phospho = phospho_ctrl
  ),
  Treat = list(
    rna     = rna_treat,
    protein = protein_treat,
    phospho = phospho_treat
  )
)

meta <- data.frame(
  modality      = c("rna", "protein", "phospho"),
  many_to_one_k = c(NA_real_, NA_real_, 4),
  modality_w    = c(1, 1, 1),
  stringsAsFactors = FALSE
)
```

## 3. Run gene-centric multi-omics clustering

Clustering is performed on the UMAP neighborhood graph derived from the
gene-centric representation.

```{r Run gene-centric multi-omics clustering, eval = TRUE}
res <- cluster_genes_multiomics(
  data         = data,
  meta         = meta,
  k            = 5L,
  gene_mode    = "intersection",
  n_neighbors  = 15L,
  verbose      = TRUE
)

cluster_table <- res$cluster_table
```

## 4. Visualize clusters in UMAP space

The UMAP embedding returned by the clustering function can be visualized
using `plot_umap_clusters()`.

```{r Visualize clusters in UMAP space, eval = TRUE}
p <- plot_umap_clusters(
  cluster_table  = cluster_table,
  umap_embedding = res$umap_fit$embedding,
  point_size     = 1.2
)

print(p)
```

## Session information

```{r session info, eval = TRUE}
sessionInfo()
```
