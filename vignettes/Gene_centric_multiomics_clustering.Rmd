---
title: "Gene-centric multiomics clustering"
author: "Thomas Rauter"
date: "19 January, 2026"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Gene-centric multiomics clustering}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    dev = "ragg_png"
)

# Ensure ComplexHeatmap’s internal png() calls don’t use Quartz on macOS
if (capabilities("cairo")) options(bitmapType = "cairo")
```

# Gene-centric multiomics clustering

This vignette explains the approach taken by the `SplineOmics` function: 
`cluster_genes_multiomics`. Figure 1 shows the methodological approach.

```{r fig-cluster-genes-multiomics, echo=FALSE, out.width="100%", fig.cap="Figure 1: Overview of the gene-centric multi-omics clustering approach. (A) Multi-omics time-series data are collected across several molecular data modalities Some modalities provide a single trajectory per gene, while others contain multiple features that map to the same gene. (B) For modalities with a many-to-one mapping to genes, all feature trajectories are jointly clustered into dynamic pattern groups (shape archetypes). For each gene, the distribution of its features across these pattern groups is summarized as a fixed-length pattern-signature vector. This preserves information from all features without collapsing them and ensures that each gene obtains a standardized representation, regardless of how many features map to it. (C) For every omics modality, a gene-gene distance matrix is computed using the corresponding gene-level trajectories or pattern-signature vectors. This yields one gene×gene distance matrix per modality, each capturing modality-specific similarity between genes. (D) The modality-specific distance matrices are combined into a unified multi-omics distance using user-defined block weights: D(i,j) = Σ w_l * d_l(i,j). The resulting integrated distance matrix reflects multi-modality similarity while preventing any single modality from dominating. (E) Genes are then clustered based on this unified distance to identify coherent multi-omics gene modules."}
knitr::include_graphics("https://raw.githubusercontent.com/csbg/SplineOmics_html_reports/main/figures/SplineOmics_%20cluster_genes_multiomics_approach.png")
```

Here is now shown how to use `cluster_genes_multiomics()` on a small,
synthetic dataset. The example generates multi-omics time-series trajectories,
including a many-to-one modality (feature-level measurements mapping to genes),
and shows how to assemble the required inputs:

- `blocks` (nested list of block × modality matrices)
- `block_meta` (block-level metadata)
- `modality_meta` (modality-level metadata)

The function returns a named list with two tibbles:

- `cluster_table`: per-gene cluster assignments per block
- `centroid_info`: per-block, per-modality centroid trajectories and
  within-cluster coherence summaries (and optionally per-member R² vectors)

```{r Load the packages, eval = TRUE}
library(SplineOmics)
library(tibble)
library(ggplot2)
```

## 1. Simulate multi-omics time-series data

We generate two blocks (conditions): `Constant` and `Temp_shifted`. Each block
contains three modalities:

- `rna` (one-to-one; one trajectory per gene)
- `protein` (one-to-one; one trajectory per gene)
- `phospho` (many-to-one; multiple features map to each gene)

The synthetic data uses a small set of canonical temporal shapes and assigns
each gene to one latent shape (for simulation only).

```{r simulate dataset, eval = TRUE}
set.seed(1)

n_genes <- 40
genes <- paste0("gene", seq_len(n_genes))

n_tp <- 9
t <- seq(0, 1, length.out = n_tp)

.add_noise <- function(x, sd = 0.15) {
  x + rnorm(length(x), mean = 0, sd = sd)
}

.shape_sin  <- function(t) sin(2 * pi * t)
.shape_cos  <- function(t) cos(2 * pi * t)
.shape_up   <- function(t) 2 * t - 1
.shape_down <- function(t) 1 - 2 * t
.shape_peak <- function(t) exp(-((t - 0.5) / 0.18)^2) * 2 - 1

shapes <- list(
  S1 = .shape_sin(t),
  S2 = .shape_cos(t),
  S3 = .shape_up(t),
  S4 = .shape_down(t),
  S5 = .shape_peak(t)
)

true_k <- 5
gene_group <- sample(seq_len(true_k), n_genes, replace = TRUE)
```

### 1.1 Simulate RNA and protein (one-to-one)

RNA is simulated from the latent shapes with noise. Protein is simulated as a
lagged and scaled version of RNA (with additional noise), mimicking delayed
protein dynamics relative to transcripts.

```{r simulate one to one data modalities, eval = TRUE}
.simulate_one_to_one <- function(genes, shapes, gene_group, noise_sd = 0.18) {
  n_genes <- length(genes)
  n_tp <- length(shapes[[1]])
  X <- matrix(
    NA_real_,
    nrow = n_genes,
    ncol = n_tp,
    dimnames = list(genes, paste0("tp", seq_len(n_tp)))
  )

  for (i in seq_len(n_genes)) {
    k <- gene_group[i]
    base <- shapes[[k]]
    X[i, ] <- .add_noise(base, sd = noise_sd)
  }

  X
}

rna_constant <- .simulate_one_to_one(
  genes = genes,
  shapes = shapes,
  gene_group = gene_group,
  noise_sd = 0.16
)

rna_temp <- rna_constant
for (i in seq_len(n_genes)) {
  k <- gene_group[i]
  warp <- if (k %in% c(1, 5)) 0.25 else 0.10
  rna_temp[i, ] <- .add_noise(shapes[[k]] + warp * t, sd = 0.16)
}
rownames(rna_temp) <- genes
colnames(rna_temp) <- colnames(rna_constant)

.lag_vec <- function(x, lag = 1) {
  if (lag <= 0) return(x)
  c(rep(x[1], lag), x[seq_len(length(x) - lag)])
}

protein_constant <- rna_constant
for (i in seq_len(n_genes)) {
  v <- rna_constant[i, ]
  protein_constant[i, ] <- .add_noise(0.8 * .lag_vec(v, lag = 1), sd = 0.18)
}
rownames(protein_constant) <- genes
colnames(protein_constant) <- colnames(rna_constant)

protein_temp <- rna_temp
for (i in seq_len(n_genes)) {
  v <- rna_temp[i, ]
  protein_temp[i, ] <- .add_noise(0.85 * .lag_vec(v, lag = 1), sd = 0.18)
}
rownames(protein_temp) <- genes
colnames(protein_temp) <- colnames(rna_temp)
```

### 1.2 Simulate phospho features (many-to-one)

For each gene, we create 1–4 phospho features. Each feature follows the gene’s
latent shape with feature-specific perturbations. Rows are named
`<gene>_<feature>` to encode the many-to-one mapping.

```{r simulate many to one data modality, eval = TRUE}
.simulate_many_to_one <- function(genes, shapes, gene_group,
                                  min_feat = 1, max_feat = 4,
                                  noise_sd = 0.20) {
  feat_counts <- sample(min_feat:max_feat, length(genes), replace = TRUE)

  feat_ids <- unlist(
    mapply(
      function(g, n) paste0(g, "_p", seq_len(n)),
      genes, feat_counts,
      SIMPLIFY = FALSE
    ),
    use.names = FALSE
  )

  n_feat <- length(feat_ids)
  n_tp <- length(shapes[[1]])

  X <- matrix(
    NA_real_,
    nrow = n_feat,
    ncol = n_tp,
    dimnames = list(feat_ids, paste0("tp", seq_len(n_tp)))
  )

  idx <- 0L
  for (i in seq_along(genes)) {
    k <- gene_group[i]
    base <- shapes[[k]]

    n_f <- feat_counts[i]
    for (j in seq_len(n_f)) {
      idx <- idx + 1L

      amp <- runif(1, 0.7, 1.3)
      drift <- runif(1, -0.25, 0.25)
      X[idx, ] <- .add_noise(amp * base + drift * t, sd = noise_sd)
    }
  }

  X
}

phospho_constant <- .simulate_many_to_one(genes, shapes, gene_group)

phospho_temp <- phospho_constant
for (i in seq_len(nrow(phospho_temp))) {
  g <- sub("_.*$", "", rownames(phospho_temp)[i])
  gi <- match(g, genes)
  k <- gene_group[gi]
  bump <- if (k %in% c(2, 4)) 0.35 else 0.12
  phospho_temp[i, ] <- .add_noise(phospho_temp[i, ] + bump * t, sd = 0.20)
}
```

## 2. Build inputs for `cluster_genes_multiomics()`

Each block is a list of modality matrices. `block_meta` defines the number of
gene clusters per block and the result category. `modality_meta` specifies, per
(block × modality), whether a modality is one-to-one (`layer_k = NA`) or many-to-
one (`layer_k` positive), and the relative layer weights.

```{r prepare blocks and blocks meta, eval = TRUE}
blocks <- list(
  Constant = list(
    rna     = rna_constant,
    protein = protein_constant,
    phospho = phospho_constant
  ),
  Temp_shifted = list(
    rna     = rna_temp,
    protein = protein_temp,
    phospho = phospho_temp
  )
)

block_clusters <- list(
    Constant     = 5L,
    Temp_shifted = 5L
)

modality_meta <- data.frame(
  block   = rep(c("Constant", "Temp_shifted"), each = 3),
  layer   = rep(c("rna", "protein", "phospho"), times = 2),
  layer_k = c(NA_real_, NA_real_, 4,
              NA_real_, NA_real_, 4),
  layer_w = c(1, 1, 1,
              1, 1, 1)
)
```

## 3. Run gene-centric multi-omics clustering

The function returns a list with `cluster_table` and `centroid_info`.

```{r run cluster_genes_multiomics, eval = TRUE}
res <- cluster_genes_multiomics(
  blocks        = blocks,
  block_clusters = block_clusters,
  modality_meta = modality_meta,
  gene_mode     = "intersection",
  verbose       = TRUE
)

cluster_table <- res$cluster_table
centroid_info <- res$centroid_info
```

## 4. Inspect `cluster_table`

`cluster_table` contains one row per gene and one cluster assignment column per
block. For time-effect blocks (result category 1), these columns are named
`cluster_<cond>`.

```{r inspect cluster_table, eval = TRUE}
cluster_table

table(cluster_table$cluster_Constant, useNA = "ifany")
table(cluster_table$cluster_Temp_shifted, useNA = "ifany")
```

## 5. Inspect `centroid_info`

`centroid_info` summarizes, for each (block × modality × cluster), the centroid
trajectory (list-column) and coherence metrics (mean and sd of per-gene R²).
If your implementation stores per-member R² values in `r2_member`, you can use
those to inspect outliers within a cluster.

```{r inspect centroid_info, eval = TRUE}
centroid_info

subset(
  centroid_info,
  block == "Constant" & modality == "rna",
  select = c("block", "modality", "cluster", "n_genes_used",
             "coverage", "mean_R2", "sd_R2")
)
```

### 5.1 Plot a centroid trajectory

Centroids are stored as numeric vectors in a list-column. Use `[[ ]]` to extract
a single centroid and plot it.

```{r plot centroid trajectory, eval = TRUE}
ci_rna_const <- subset(
  centroid_info,
  block == "Constant" & modality == "rna"
)

i <- 1

centroid_df <- data.frame(
  time  = seq_along(ci_rna_const$centroid[[i]]),
  value = ci_rna_const$centroid[[i]]
)

ggplot(centroid_df, aes(x = time, y = value)) +
  geom_line(linewidth = 0.9) +
  geom_point(size = 1.8) +
  labs(
    title = paste(
      "Centroid trajectory:",
      ci_rna_const$block[i],
      ci_rna_const$modality[i],
      "cluster", ci_rna_const$cluster[i]
    ),
    x = "Spline / time point",
    y = "Centroid (z-scored)"
  ) +
  theme_bw()

```

### 5.2 Inspect per-member R² values

If your `centroid_info` includes a list-column `r2_member` (named numeric
vectors of per-gene R²), you can examine the distribution and identify low-fit
genes. If the column does not exist, this section will be skipped.

```{r inspect per-member R2 values, eval = TRUE}
if ("r2_member" %in% names(ci_rna_const)) {

  i <- 1
  r2 <- ci_rna_const$r2_member[[i]]

  print(head(r2))
  print(summary(r2))

  r2_df <- data.frame(
    gene = names(r2),
    R2   = unname(r2)
  )

  p <- ggplot(r2_df, aes(x = R2)) +
    geom_histogram(
      bins = 15,
      colour = "black",
      fill = "grey80"
    ) +
    labs(
      title = paste(
        "Per-gene R² to centroid:",
        ci_rna_const$block[i],
        ci_rna_const$modality[i],
        "cluster", ci_rna_const$cluster[i]
      ),
      x = expression(R^2),
      y = "Gene count"
    ) +
    theme_bw()

  print(p)

  bad <- r2_df$gene[r2_df$R2 < 0.2]
  print(bad)

} else {
  message("No r2_member column found in centroid_info (optional feature).")
}
```


# Session Info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
